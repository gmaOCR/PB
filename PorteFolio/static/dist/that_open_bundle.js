/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ThatOpen"] = factory();
	else
		root["ThatOpen"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./static/js/that_open.js":
/*!********************************!*\
  !*** ./static/js/that_open.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   panel: () => (/* binding */ panel)\n/* harmony export */ });\n/* harmony import */ var _thatopen_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @thatopen/ui */ \"./node_modules/@thatopen/ui/dist/index.js\");\nvar _templateObject;\nfunction _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }\n\n_thatopen_ui__WEBPACK_IMPORTED_MODULE_0__.Manager.init();\n\nvar panel = _thatopen_ui__WEBPACK_IMPORTED_MODULE_0__.Component.create < _thatopen_ui__WEBPACK_IMPORTED_MODULE_0__.Panel > function () {\n  var counter = 0;\n  var onUpdateBtnClick = function onUpdateBtnClick() {\n    counter++;\n    if (counter >= 5) {\n      updateStatefullPanelSection({\n        label: \"Powered Statefull Panel Section ðŸ’ª\",\n        counter: counter\n      });\n    } else {\n      updateStatefullPanelSection({\n        counter: counter\n      });\n    }\n  };\n  return _thatopen_ui__WEBPACK_IMPORTED_MODULE_0__.html(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      <bim-panel label=\\\"My Panel\\\">\\n        <bim-panel-section label=\\\"Update Functions\\\">\\n          <bim-button @click=\", \" label=\\\"Update Statefull Section\\\"></bim-button>\\n        </bim-panel-section>\\n        \", \"\\n        \", \"\\n      </bim-panel>\\n    \"])), onUpdateBtnClick, statelessPanelSection, statefullPanelSection);\n};\ndocument.body.append(panel);\n\n\n//# sourceURL=webpack://ThatOpen/./static/js/that_open.js?");

/***/ }),

/***/ "./webpack.config.js":
/*!***************************!*\
  !*** ./webpack.config.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var __dirname = \"/\";\nvar _require = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\"),\n  resolve = _require.resolve;\nmodule.exports = {\n  entry: './static/js/that_open.js',\n  output: {\n    filename: 'that_open_bundle.js',\n    path: resolve(__dirname, 'static/dist'),\n    publicPath: '/static/dist/',\n    library: {\n      type: 'umd',\n      name: 'ThatOpen',\n      \"export\": 'panel'\n    }\n  },\n  resolve: {\n    fallback: {\n      \"path\": /*require.resolve*/(/*! path-browserify */ \"./node_modules/path-browserify/index.js\")\n    },\n    modules: ['node_modules'],\n    alias: {\n      '@thatopen/ui': resolve(__dirname, 'node_modules/@thatopen/ui')\n    }\n  },\n  mode: 'development',\n  module: {\n    rules: [{\n      test: /\\.m?js$/,\n      exclude: /node_modules/,\n      use: {\n        loader: 'babel-loader',\n        options: {\n          presets: ['@babel/preset-env']\n        }\n      }\n    }]\n  }\n};\n\n//# sourceURL=webpack://ThatOpen/./webpack.config.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n//# sourceURL=webpack://ThatOpen/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/@thatopen/ui/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@thatopen/ui/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Vo),\n/* harmony export */   Checkbox: () => (/* binding */ at),\n/* harmony export */   ColorInput: () => (/* binding */ X),\n/* harmony export */   Component: () => (/* binding */ Jo),\n/* harmony export */   ContextMenu: () => (/* binding */ Oe),\n/* harmony export */   Dropdown: () => (/* binding */ B),\n/* harmony export */   Grid: () => (/* binding */ ie),\n/* harmony export */   Icon: () => (/* binding */ fi),\n/* harmony export */   Input: () => (/* binding */ Et),\n/* harmony export */   Label: () => (/* binding */ ct),\n/* harmony export */   Manager: () => (/* binding */ pi),\n/* harmony export */   NumberInput: () => (/* binding */ L),\n/* harmony export */   Option: () => (/* binding */ P),\n/* harmony export */   Panel: () => (/* binding */ ut),\n/* harmony export */   PanelSection: () => (/* binding */ ht),\n/* harmony export */   Selector: () => (/* binding */ dt),\n/* harmony export */   Tab: () => (/* binding */ I),\n/* harmony export */   Table: () => (/* binding */ J),\n/* harmony export */   TableCell: () => (/* binding */ Pe),\n/* harmony export */   TableChildren: () => (/* binding */ Te),\n/* harmony export */   TableGroup: () => (/* binding */ Le),\n/* harmony export */   TableRow: () => (/* binding */ ft),\n/* harmony export */   Tabs: () => (/* binding */ K),\n/* harmony export */   TextInput: () => (/* binding */ N),\n/* harmony export */   Toolbar: () => (/* binding */ jt),\n/* harmony export */   ToolbarGroup: () => (/* binding */ Mt),\n/* harmony export */   ToolbarSection: () => (/* binding */ pt),\n/* harmony export */   Viewport: () => (/* binding */ Ie),\n/* harmony export */   html: () => (/* binding */ m),\n/* harmony export */   ref: () => (/* binding */ st),\n/* harmony export */   styleMap: () => (/* binding */ Dl)\n/* harmony export */ });\nvar Rs = Object.defineProperty;\nvar Ms = (i, t, e) => t in i ? Rs(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;\nvar tt = (i, t, e) => (Ms(i, typeof t != \"symbol\" ? t + \"\" : t, e), e);\nconst Tt = Math.min, Q = Math.max, _e = Math.round, rt = (i) => ({\n  x: i,\n  y: i\n}), js = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n}, Bs = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction Ki(i, t, e) {\n  return Q(i, Tt(t, e));\n}\nfunction ne(i, t) {\n  return typeof i == \"function\" ? i(t) : i;\n}\nfunction Y(i) {\n  return i.split(\"-\")[0];\n}\nfunction Re(i) {\n  return i.split(\"-\")[1];\n}\nfunction Rn(i) {\n  return i === \"x\" ? \"y\" : \"x\";\n}\nfunction Mn(i) {\n  return i === \"y\" ? \"height\" : \"width\";\n}\nfunction se(i) {\n  return [\"top\", \"bottom\"].includes(Y(i)) ? \"y\" : \"x\";\n}\nfunction jn(i) {\n  return Rn(se(i));\n}\nfunction Ns(i, t, e) {\n  e === void 0 && (e = !1);\n  const s = Re(i), n = jn(i), r = Mn(n);\n  let o = n === \"x\" ? s === (e ? \"end\" : \"start\") ? \"right\" : \"left\" : s === \"start\" ? \"bottom\" : \"top\";\n  return t.reference[r] > t.floating[r] && (o = xe(o)), [o, xe(o)];\n}\nfunction Hs(i) {\n  const t = xe(i);\n  return [ei(i), t, ei(t)];\n}\nfunction ei(i) {\n  return i.replace(/start|end/g, (t) => Bs[t]);\n}\nfunction Ds(i, t, e) {\n  const s = [\"left\", \"right\"], n = [\"right\", \"left\"], r = [\"top\", \"bottom\"], o = [\"bottom\", \"top\"];\n  switch (i) {\n    case \"top\":\n    case \"bottom\":\n      return e ? t ? n : s : t ? s : n;\n    case \"left\":\n    case \"right\":\n      return t ? r : o;\n    default:\n      return [];\n  }\n}\nfunction Fs(i, t, e, s) {\n  const n = Re(i);\n  let r = Ds(Y(i), e === \"start\", s);\n  return n && (r = r.map((o) => o + \"-\" + n), t && (r = r.concat(r.map(ei)))), r;\n}\nfunction xe(i) {\n  return i.replace(/left|right|bottom|top/g, (t) => js[t]);\n}\nfunction Vs(i) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...i\n  };\n}\nfunction Bn(i) {\n  return typeof i != \"number\" ? Vs(i) : {\n    top: i,\n    right: i,\n    bottom: i,\n    left: i\n  };\n}\nfunction Lt(i) {\n  const {\n    x: t,\n    y: e,\n    width: s,\n    height: n\n  } = i;\n  return {\n    width: s,\n    height: n,\n    top: e,\n    left: t,\n    right: t + s,\n    bottom: e + n,\n    x: t,\n    y: e\n  };\n}\nfunction Zi(i, t, e) {\n  let {\n    reference: s,\n    floating: n\n  } = i;\n  const r = se(t), o = jn(t), a = Mn(o), l = Y(t), c = r === \"y\", u = s.x + s.width / 2 - n.width / 2, h = s.y + s.height / 2 - n.height / 2, f = s[a] / 2 - n[a] / 2;\n  let p;\n  switch (l) {\n    case \"top\":\n      p = {\n        x: u,\n        y: s.y - n.height\n      };\n      break;\n    case \"bottom\":\n      p = {\n        x: u,\n        y: s.y + s.height\n      };\n      break;\n    case \"right\":\n      p = {\n        x: s.x + s.width,\n        y: h\n      };\n      break;\n    case \"left\":\n      p = {\n        x: s.x - n.width,\n        y: h\n      };\n      break;\n    default:\n      p = {\n        x: s.x,\n        y: s.y\n      };\n  }\n  switch (Re(t)) {\n    case \"start\":\n      p[o] -= f * (e && c ? -1 : 1);\n      break;\n    case \"end\":\n      p[o] += f * (e && c ? -1 : 1);\n      break;\n  }\n  return p;\n}\nconst Us = async (i, t, e) => {\n  const {\n    placement: s = \"bottom\",\n    strategy: n = \"absolute\",\n    middleware: r = [],\n    platform: o\n  } = e, a = r.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));\n  let c = await o.getElementRects({\n    reference: i,\n    floating: t,\n    strategy: n\n  }), {\n    x: u,\n    y: h\n  } = Zi(c, s, l), f = s, p = {}, b = 0;\n  for (let v = 0; v < a.length; v++) {\n    const {\n      name: g,\n      fn: A\n    } = a[v], {\n      x: E,\n      y: x,\n      data: $,\n      reset: S\n    } = await A({\n      x: u,\n      y: h,\n      initialPlacement: s,\n      placement: f,\n      strategy: n,\n      middlewareData: p,\n      rects: c,\n      platform: o,\n      elements: {\n        reference: i,\n        floating: t\n      }\n    });\n    u = E ?? u, h = x ?? h, p = {\n      ...p,\n      [g]: {\n        ...p[g],\n        ...$\n      }\n    }, S && b <= 50 && (b++, typeof S == \"object\" && (S.placement && (f = S.placement), S.rects && (c = S.rects === !0 ? await o.getElementRects({\n      reference: i,\n      floating: t,\n      strategy: n\n    }) : S.rects), {\n      x: u,\n      y: h\n    } = Zi(c, f, l)), v = -1);\n  }\n  return {\n    x: u,\n    y: h,\n    placement: f,\n    strategy: n,\n    middlewareData: p\n  };\n};\nasync function mi(i, t) {\n  var e;\n  t === void 0 && (t = {});\n  const {\n    x: s,\n    y: n,\n    platform: r,\n    rects: o,\n    elements: a,\n    strategy: l\n  } = i, {\n    boundary: c = \"clippingAncestors\",\n    rootBoundary: u = \"viewport\",\n    elementContext: h = \"floating\",\n    altBoundary: f = !1,\n    padding: p = 0\n  } = ne(t, i), b = Bn(p), g = a[f ? h === \"floating\" ? \"reference\" : \"floating\" : h], A = Lt(await r.getClippingRect({\n    element: (e = await (r.isElement == null ? void 0 : r.isElement(g))) == null || e ? g : g.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),\n    boundary: c,\n    rootBoundary: u,\n    strategy: l\n  })), E = h === \"floating\" ? {\n    x: s,\n    y: n,\n    width: o.floating.width,\n    height: o.floating.height\n  } : o.reference, x = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating)), $ = await (r.isElement == null ? void 0 : r.isElement(x)) ? await (r.getScale == null ? void 0 : r.getScale(x)) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  }, S = Lt(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements: a,\n    rect: E,\n    offsetParent: x,\n    strategy: l\n  }) : E);\n  return {\n    top: (A.top - S.top + b.top) / $.y,\n    bottom: (S.bottom - A.bottom + b.bottom) / $.y,\n    left: (A.left - S.left + b.left) / $.x,\n    right: (S.right - A.right + b.right) / $.x\n  };\n}\nconst qs = function(i) {\n  return i === void 0 && (i = {}), {\n    name: \"flip\",\n    options: i,\n    async fn(t) {\n      var e, s;\n      const {\n        placement: n,\n        middlewareData: r,\n        rects: o,\n        initialPlacement: a,\n        platform: l,\n        elements: c\n      } = t, {\n        mainAxis: u = !0,\n        crossAxis: h = !0,\n        fallbackPlacements: f,\n        fallbackStrategy: p = \"bestFit\",\n        fallbackAxisSideDirection: b = \"none\",\n        flipAlignment: v = !0,\n        ...g\n      } = ne(i, t);\n      if ((e = r.arrow) != null && e.alignmentOffset)\n        return {};\n      const A = Y(n), E = Y(a) === a, x = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), $ = f || (E || !v ? [xe(a)] : Hs(a));\n      !f && b !== \"none\" && $.push(...Fs(a, v, b, x));\n      const S = [a, ...$], y = await mi(t, g), T = [];\n      let z = ((s = r.flip) == null ? void 0 : s.overflows) || [];\n      if (u && T.push(y[A]), h) {\n        const D = Ns(n, o, x);\n        T.push(y[D[0]], y[D[1]]);\n      }\n      if (z = [...z, {\n        placement: n,\n        overflows: T\n      }], !T.every((D) => D <= 0)) {\n        var q, O;\n        const D = (((q = r.flip) == null ? void 0 : q.index) || 0) + 1, Ot = S[D];\n        if (Ot)\n          return {\n            data: {\n              index: D,\n              overflows: z\n            },\n            reset: {\n              placement: Ot\n            }\n          };\n        let Z = (O = z.filter((F) => F.overflows[0] <= 0).sort((F, W) => F.overflows[1] - W.overflows[1])[0]) == null ? void 0 : O.placement;\n        if (!Z)\n          switch (p) {\n            case \"bestFit\": {\n              var St;\n              const F = (St = z.map((W) => [W.placement, W.overflows.filter((yt) => yt > 0).reduce((yt, qe) => yt + qe, 0)]).sort((W, yt) => W[1] - yt[1])[0]) == null ? void 0 : St[0];\n              F && (Z = F);\n              break;\n            }\n            case \"initialPlacement\":\n              Z = a;\n              break;\n          }\n        if (n !== Z)\n          return {\n            reset: {\n              placement: Z\n            }\n          };\n      }\n      return {};\n    }\n  };\n};\nfunction Nn(i) {\n  const t = Tt(...i.map((r) => r.left)), e = Tt(...i.map((r) => r.top)), s = Q(...i.map((r) => r.right)), n = Q(...i.map((r) => r.bottom));\n  return {\n    x: t,\n    y: e,\n    width: s - t,\n    height: n - e\n  };\n}\nfunction Ws(i) {\n  const t = i.slice().sort((n, r) => n.y - r.y), e = [];\n  let s = null;\n  for (let n = 0; n < t.length; n++) {\n    const r = t[n];\n    !s || r.y - s.y > s.height / 2 ? e.push([r]) : e[e.length - 1].push(r), s = r;\n  }\n  return e.map((n) => Lt(Nn(n)));\n}\nconst Qs = function(i) {\n  return i === void 0 && (i = {}), {\n    name: \"inline\",\n    options: i,\n    async fn(t) {\n      const {\n        placement: e,\n        elements: s,\n        rects: n,\n        platform: r,\n        strategy: o\n      } = t, {\n        padding: a = 2,\n        x: l,\n        y: c\n      } = ne(i, t), u = Array.from(await (r.getClientRects == null ? void 0 : r.getClientRects(s.reference)) || []), h = Ws(u), f = Lt(Nn(u)), p = Bn(a);\n      function b() {\n        if (h.length === 2 && h[0].left > h[1].right && l != null && c != null)\n          return h.find((g) => l > g.left - p.left && l < g.right + p.right && c > g.top - p.top && c < g.bottom + p.bottom) || f;\n        if (h.length >= 2) {\n          if (se(e) === \"y\") {\n            const O = h[0], St = h[h.length - 1], D = Y(e) === \"top\", Ot = O.top, Z = St.bottom, F = D ? O.left : St.left, W = D ? O.right : St.right, yt = W - F, qe = Z - Ot;\n            return {\n              top: Ot,\n              bottom: Z,\n              left: F,\n              right: W,\n              width: yt,\n              height: qe,\n              x: F,\n              y: Ot\n            };\n          }\n          const g = Y(e) === \"left\", A = Q(...h.map((O) => O.right)), E = Tt(...h.map((O) => O.left)), x = h.filter((O) => g ? O.left === E : O.right === A), $ = x[0].top, S = x[x.length - 1].bottom, y = E, T = A, z = T - y, q = S - $;\n          return {\n            top: $,\n            bottom: S,\n            left: y,\n            right: T,\n            width: z,\n            height: q,\n            x: y,\n            y: $\n          };\n        }\n        return f;\n      }\n      const v = await r.getElementRects({\n        reference: {\n          getBoundingClientRect: b\n        },\n        floating: s.floating,\n        strategy: o\n      });\n      return n.reference.x !== v.reference.x || n.reference.y !== v.reference.y || n.reference.width !== v.reference.width || n.reference.height !== v.reference.height ? {\n        reset: {\n          rects: v\n        }\n      } : {};\n    }\n  };\n};\nasync function Ys(i, t) {\n  const {\n    placement: e,\n    platform: s,\n    elements: n\n  } = i, r = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), o = Y(e), a = Re(e), l = se(e) === \"y\", c = [\"left\", \"top\"].includes(o) ? -1 : 1, u = r && l ? -1 : 1, h = ne(t, i);\n  let {\n    mainAxis: f,\n    crossAxis: p,\n    alignmentAxis: b\n  } = typeof h == \"number\" ? {\n    mainAxis: h,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...h\n  };\n  return a && typeof b == \"number\" && (p = a === \"end\" ? b * -1 : b), l ? {\n    x: p * u,\n    y: f * c\n  } : {\n    x: f * c,\n    y: p * u\n  };\n}\nconst Hn = function(i) {\n  return {\n    name: \"offset\",\n    options: i,\n    async fn(t) {\n      var e, s;\n      const {\n        x: n,\n        y: r,\n        placement: o,\n        middlewareData: a\n      } = t, l = await Ys(t, i);\n      return o === ((e = a.offset) == null ? void 0 : e.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {\n        x: n + l.x,\n        y: r + l.y,\n        data: {\n          ...l,\n          placement: o\n        }\n      };\n    }\n  };\n}, Gs = function(i) {\n  return i === void 0 && (i = {}), {\n    name: \"shift\",\n    options: i,\n    async fn(t) {\n      const {\n        x: e,\n        y: s,\n        placement: n\n      } = t, {\n        mainAxis: r = !0,\n        crossAxis: o = !1,\n        limiter: a = {\n          fn: (g) => {\n            let {\n              x: A,\n              y: E\n            } = g;\n            return {\n              x: A,\n              y: E\n            };\n          }\n        },\n        ...l\n      } = ne(i, t), c = {\n        x: e,\n        y: s\n      }, u = await mi(t, l), h = se(Y(n)), f = Rn(h);\n      let p = c[f], b = c[h];\n      if (r) {\n        const g = f === \"y\" ? \"top\" : \"left\", A = f === \"y\" ? \"bottom\" : \"right\", E = p + u[g], x = p - u[A];\n        p = Ki(E, p, x);\n      }\n      if (o) {\n        const g = h === \"y\" ? \"top\" : \"left\", A = h === \"y\" ? \"bottom\" : \"right\", E = b + u[g], x = b - u[A];\n        b = Ki(E, b, x);\n      }\n      const v = a.fn({\n        ...t,\n        [f]: p,\n        [h]: b\n      });\n      return {\n        ...v,\n        data: {\n          x: v.x - e,\n          y: v.y - s\n        }\n      };\n    }\n  };\n};\nfunction ot(i) {\n  return Dn(i) ? (i.nodeName || \"\").toLowerCase() : \"#document\";\n}\nfunction R(i) {\n  var t;\n  return (i == null || (t = i.ownerDocument) == null ? void 0 : t.defaultView) || window;\n}\nfunction mt(i) {\n  var t;\n  return (t = (Dn(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : t.documentElement;\n}\nfunction Dn(i) {\n  return i instanceof Node || i instanceof R(i).Node;\n}\nfunction G(i) {\n  return i instanceof Element || i instanceof R(i).Element;\n}\nfunction V(i) {\n  return i instanceof HTMLElement || i instanceof R(i).HTMLElement;\n}\nfunction tn(i) {\n  return typeof ShadowRoot > \"u\" ? !1 : i instanceof ShadowRoot || i instanceof R(i).ShadowRoot;\n}\nfunction re(i) {\n  const {\n    overflow: t,\n    overflowX: e,\n    overflowY: s,\n    display: n\n  } = M(i);\n  return /auto|scroll|overlay|hidden|clip/.test(t + s + e) && ![\"inline\", \"contents\"].includes(n);\n}\nfunction Xs(i) {\n  return [\"table\", \"td\", \"th\"].includes(ot(i));\n}\nfunction bi(i) {\n  const t = gi(), e = M(i);\n  return e.transform !== \"none\" || e.perspective !== \"none\" || (e.containerType ? e.containerType !== \"normal\" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== \"none\" : !1) || !t && (e.filter ? e.filter !== \"none\" : !1) || [\"transform\", \"perspective\", \"filter\"].some((s) => (e.willChange || \"\").includes(s)) || [\"paint\", \"layout\", \"strict\", \"content\"].some((s) => (e.contain || \"\").includes(s));\n}\nfunction Js(i) {\n  let t = It(i);\n  for (; V(t) && !Me(t); ) {\n    if (bi(t))\n      return t;\n    t = It(t);\n  }\n  return null;\n}\nfunction gi() {\n  return typeof CSS > \"u\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction Me(i) {\n  return [\"html\", \"body\", \"#document\"].includes(ot(i));\n}\nfunction M(i) {\n  return R(i).getComputedStyle(i);\n}\nfunction je(i) {\n  return G(i) ? {\n    scrollLeft: i.scrollLeft,\n    scrollTop: i.scrollTop\n  } : {\n    scrollLeft: i.pageXOffset,\n    scrollTop: i.pageYOffset\n  };\n}\nfunction It(i) {\n  if (ot(i) === \"html\")\n    return i;\n  const t = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    i.assignedSlot || // DOM Element detected.\n    i.parentNode || // ShadowRoot detected.\n    tn(i) && i.host || // Fallback.\n    mt(i)\n  );\n  return tn(t) ? t.host : t;\n}\nfunction Fn(i) {\n  const t = It(i);\n  return Me(t) ? i.ownerDocument ? i.ownerDocument.body : i.body : V(t) && re(t) ? t : Fn(t);\n}\nfunction ii(i, t, e) {\n  var s;\n  t === void 0 && (t = []), e === void 0 && (e = !0);\n  const n = Fn(i), r = n === ((s = i.ownerDocument) == null ? void 0 : s.body), o = R(n);\n  return r ? t.concat(o, o.visualViewport || [], re(n) ? n : [], o.frameElement && e ? ii(o.frameElement) : []) : t.concat(n, ii(n, [], e));\n}\nfunction Vn(i) {\n  const t = M(i);\n  let e = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;\n  const n = V(i), r = n ? i.offsetWidth : e, o = n ? i.offsetHeight : s, a = _e(e) !== r || _e(s) !== o;\n  return a && (e = r, s = o), {\n    width: e,\n    height: s,\n    $: a\n  };\n}\nfunction Un(i) {\n  return G(i) ? i : i.contextElement;\n}\nfunction Pt(i) {\n  const t = Un(i);\n  if (!V(t))\n    return rt(1);\n  const e = t.getBoundingClientRect(), {\n    width: s,\n    height: n,\n    $: r\n  } = Vn(t);\n  let o = (r ? _e(e.width) : e.width) / s, a = (r ? _e(e.height) : e.height) / n;\n  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {\n    x: o,\n    y: a\n  };\n}\nconst Ks = /* @__PURE__ */ rt(0);\nfunction qn(i) {\n  const t = R(i);\n  return !gi() || !t.visualViewport ? Ks : {\n    x: t.visualViewport.offsetLeft,\n    y: t.visualViewport.offsetTop\n  };\n}\nfunction Zs(i, t, e) {\n  return t === void 0 && (t = !1), !e || t && e !== R(i) ? !1 : t;\n}\nfunction Gt(i, t, e, s) {\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\n  const n = i.getBoundingClientRect(), r = Un(i);\n  let o = rt(1);\n  t && (s ? G(s) && (o = Pt(s)) : o = Pt(i));\n  const a = Zs(r, e, s) ? qn(r) : rt(0);\n  let l = (n.left + a.x) / o.x, c = (n.top + a.y) / o.y, u = n.width / o.x, h = n.height / o.y;\n  if (r) {\n    const f = R(r), p = s && G(s) ? R(s) : s;\n    let b = f, v = b.frameElement;\n    for (; v && s && p !== b; ) {\n      const g = Pt(v), A = v.getBoundingClientRect(), E = M(v), x = A.left + (v.clientLeft + parseFloat(E.paddingLeft)) * g.x, $ = A.top + (v.clientTop + parseFloat(E.paddingTop)) * g.y;\n      l *= g.x, c *= g.y, u *= g.x, h *= g.y, l += x, c += $, b = R(v), v = b.frameElement;\n    }\n  }\n  return Lt({\n    width: u,\n    height: h,\n    x: l,\n    y: c\n  });\n}\nconst tr = [\":popover-open\", \":modal\"];\nfunction Wn(i) {\n  return tr.some((t) => {\n    try {\n      return i.matches(t);\n    } catch {\n      return !1;\n    }\n  });\n}\nfunction er(i) {\n  let {\n    elements: t,\n    rect: e,\n    offsetParent: s,\n    strategy: n\n  } = i;\n  const r = n === \"fixed\", o = mt(s), a = t ? Wn(t.floating) : !1;\n  if (s === o || a && r)\n    return e;\n  let l = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, c = rt(1);\n  const u = rt(0), h = V(s);\n  if ((h || !h && !r) && ((ot(s) !== \"body\" || re(o)) && (l = je(s)), V(s))) {\n    const f = Gt(s);\n    c = Pt(s), u.x = f.x + s.clientLeft, u.y = f.y + s.clientTop;\n  }\n  return {\n    width: e.width * c.x,\n    height: e.height * c.y,\n    x: e.x * c.x - l.scrollLeft * c.x + u.x,\n    y: e.y * c.y - l.scrollTop * c.y + u.y\n  };\n}\nfunction ir(i) {\n  return Array.from(i.getClientRects());\n}\nfunction Qn(i) {\n  return Gt(mt(i)).left + je(i).scrollLeft;\n}\nfunction nr(i) {\n  const t = mt(i), e = je(i), s = i.ownerDocument.body, n = Q(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), r = Q(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);\n  let o = -e.scrollLeft + Qn(i);\n  const a = -e.scrollTop;\n  return M(s).direction === \"rtl\" && (o += Q(t.clientWidth, s.clientWidth) - n), {\n    width: n,\n    height: r,\n    x: o,\n    y: a\n  };\n}\nfunction sr(i, t) {\n  const e = R(i), s = mt(i), n = e.visualViewport;\n  let r = s.clientWidth, o = s.clientHeight, a = 0, l = 0;\n  if (n) {\n    r = n.width, o = n.height;\n    const c = gi();\n    (!c || c && t === \"fixed\") && (a = n.offsetLeft, l = n.offsetTop);\n  }\n  return {\n    width: r,\n    height: o,\n    x: a,\n    y: l\n  };\n}\nfunction rr(i, t) {\n  const e = Gt(i, !0, t === \"fixed\"), s = e.top + i.clientTop, n = e.left + i.clientLeft, r = V(i) ? Pt(i) : rt(1), o = i.clientWidth * r.x, a = i.clientHeight * r.y, l = n * r.x, c = s * r.y;\n  return {\n    width: o,\n    height: a,\n    x: l,\n    y: c\n  };\n}\nfunction en(i, t, e) {\n  let s;\n  if (t === \"viewport\")\n    s = sr(i, e);\n  else if (t === \"document\")\n    s = nr(mt(i));\n  else if (G(t))\n    s = rr(t, e);\n  else {\n    const n = qn(i);\n    s = {\n      ...t,\n      x: t.x - n.x,\n      y: t.y - n.y\n    };\n  }\n  return Lt(s);\n}\nfunction Yn(i, t) {\n  const e = It(i);\n  return e === t || !G(e) || Me(e) ? !1 : M(e).position === \"fixed\" || Yn(e, t);\n}\nfunction or(i, t) {\n  const e = t.get(i);\n  if (e)\n    return e;\n  let s = ii(i, [], !1).filter((a) => G(a) && ot(a) !== \"body\"), n = null;\n  const r = M(i).position === \"fixed\";\n  let o = r ? It(i) : i;\n  for (; G(o) && !Me(o); ) {\n    const a = M(o), l = bi(o);\n    !l && a.position === \"fixed\" && (n = null), (r ? !l && !n : !l && a.position === \"static\" && !!n && [\"absolute\", \"fixed\"].includes(n.position) || re(o) && !l && Yn(i, o)) ? s = s.filter((u) => u !== o) : n = a, o = It(o);\n  }\n  return t.set(i, s), s;\n}\nfunction lr(i) {\n  let {\n    element: t,\n    boundary: e,\n    rootBoundary: s,\n    strategy: n\n  } = i;\n  const o = [...e === \"clippingAncestors\" ? or(t, this._c) : [].concat(e), s], a = o[0], l = o.reduce((c, u) => {\n    const h = en(t, u, n);\n    return c.top = Q(h.top, c.top), c.right = Tt(h.right, c.right), c.bottom = Tt(h.bottom, c.bottom), c.left = Q(h.left, c.left), c;\n  }, en(t, a, n));\n  return {\n    width: l.right - l.left,\n    height: l.bottom - l.top,\n    x: l.left,\n    y: l.top\n  };\n}\nfunction ar(i) {\n  const {\n    width: t,\n    height: e\n  } = Vn(i);\n  return {\n    width: t,\n    height: e\n  };\n}\nfunction cr(i, t, e) {\n  const s = V(t), n = mt(t), r = e === \"fixed\", o = Gt(i, !0, r, t);\n  let a = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const l = rt(0);\n  if (s || !s && !r)\n    if ((ot(t) !== \"body\" || re(n)) && (a = je(t)), s) {\n      const h = Gt(t, !0, r, t);\n      l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop;\n    } else\n      n && (l.x = Qn(n));\n  const c = o.left + a.scrollLeft - l.x, u = o.top + a.scrollTop - l.y;\n  return {\n    x: c,\n    y: u,\n    width: o.width,\n    height: o.height\n  };\n}\nfunction nn(i, t) {\n  return !V(i) || M(i).position === \"fixed\" ? null : t ? t(i) : i.offsetParent;\n}\nfunction Gn(i, t) {\n  const e = R(i);\n  if (!V(i) || Wn(i))\n    return e;\n  let s = nn(i, t);\n  for (; s && Xs(s) && M(s).position === \"static\"; )\n    s = nn(s, t);\n  return s && (ot(s) === \"html\" || ot(s) === \"body\" && M(s).position === \"static\" && !bi(s)) ? e : s || Js(i) || e;\n}\nconst ur = async function(i) {\n  const t = this.getOffsetParent || Gn, e = this.getDimensions;\n  return {\n    reference: cr(i.reference, await t(i.floating), i.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...await e(i.floating)\n    }\n  };\n};\nfunction hr(i) {\n  return M(i).direction === \"rtl\";\n}\nconst dr = {\n  convertOffsetParentRelativeRectToViewportRelativeRect: er,\n  getDocumentElement: mt,\n  getClippingRect: lr,\n  getOffsetParent: Gn,\n  getElementRects: ur,\n  getClientRects: ir,\n  getDimensions: ar,\n  getScale: Pt,\n  isElement: G,\n  isRTL: hr\n}, Xn = Gs, Jn = qs, Kn = Qs, Zn = (i, t, e) => {\n  const s = /* @__PURE__ */ new Map(), n = {\n    platform: dr,\n    ...e\n  }, r = {\n    ...n.platform,\n    _c: s\n  };\n  return Us(i, t, {\n    ...n,\n    platform: r\n  });\n};\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst ge = globalThis, vi = ge.ShadowRoot && (ge.ShadyCSS === void 0 || ge.ShadyCSS.nativeShadow) && \"adoptedStyleSheets\" in Document.prototype && \"replace\" in CSSStyleSheet.prototype, yi = Symbol(), sn = /* @__PURE__ */ new WeakMap();\nlet ts = class {\n  constructor(t, e, s) {\n    if (this._$cssResult$ = !0, s !== yi)\n      throw Error(\"CSSResult is not constructable. Use `unsafeCSS` or `css` instead.\");\n    this.cssText = t, this.t = e;\n  }\n  get styleSheet() {\n    let t = this.o;\n    const e = this.t;\n    if (vi && t === void 0) {\n      const s = e !== void 0 && e.length === 1;\n      s && (t = sn.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), s && sn.set(e, t));\n    }\n    return t;\n  }\n  toString() {\n    return this.cssText;\n  }\n};\nconst fr = (i) => new ts(typeof i == \"string\" ? i : i + \"\", void 0, yi), C = (i, ...t) => {\n  const e = i.length === 1 ? i[0] : t.reduce((s, n, r) => s + ((o) => {\n    if (o._$cssResult$ === !0)\n      return o.cssText;\n    if (typeof o == \"number\")\n      return o;\n    throw Error(\"Value passed to 'css' function must be a 'css' function result: \" + o + \". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.\");\n  })(n) + i[r + 1], i[0]);\n  return new ts(e, i, yi);\n}, pr = (i, t) => {\n  if (vi)\n    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);\n  else\n    for (const e of t) {\n      const s = document.createElement(\"style\"), n = ge.litNonce;\n      n !== void 0 && s.setAttribute(\"nonce\", n), s.textContent = e.cssText, i.appendChild(s);\n    }\n}, rn = vi ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {\n  let e = \"\";\n  for (const s of t.cssRules)\n    e += s.cssText;\n  return fr(e);\n})(i) : i;\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst { is: mr, defineProperty: br, getOwnPropertyDescriptor: gr, getOwnPropertyNames: vr, getOwnPropertySymbols: yr, getPrototypeOf: _r } = Object, it = globalThis, on = it.trustedTypes, xr = on ? on.emptyScript : \"\", We = it.reactiveElementPolyfillSupport, Ut = (i, t) => i, we = { toAttribute(i, t) {\n  switch (t) {\n    case Boolean:\n      i = i ? xr : null;\n      break;\n    case Object:\n    case Array:\n      i = i == null ? i : JSON.stringify(i);\n  }\n  return i;\n}, fromAttribute(i, t) {\n  let e = i;\n  switch (t) {\n    case Boolean:\n      e = i !== null;\n      break;\n    case Number:\n      e = i === null ? null : Number(i);\n      break;\n    case Object:\n    case Array:\n      try {\n        e = JSON.parse(i);\n      } catch {\n        e = null;\n      }\n  }\n  return e;\n} }, _i = (i, t) => !mr(i, t), ln = { attribute: !0, type: String, converter: we, reflect: !1, hasChanged: _i };\nSymbol.metadata ?? (Symbol.metadata = Symbol(\"metadata\")), it.litPropertyMetadata ?? (it.litPropertyMetadata = /* @__PURE__ */ new WeakMap());\nclass kt extends HTMLElement {\n  static addInitializer(t) {\n    this._$Ei(), (this.l ?? (this.l = [])).push(t);\n  }\n  static get observedAttributes() {\n    return this.finalize(), this._$Eh && [...this._$Eh.keys()];\n  }\n  static createProperty(t, e = ln) {\n    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {\n      const s = Symbol(), n = this.getPropertyDescriptor(t, s, e);\n      n !== void 0 && br(this.prototype, t, n);\n    }\n  }\n  static getPropertyDescriptor(t, e, s) {\n    const { get: n, set: r } = gr(this.prototype, t) ?? { get() {\n      return this[e];\n    }, set(o) {\n      this[e] = o;\n    } };\n    return { get() {\n      return n == null ? void 0 : n.call(this);\n    }, set(o) {\n      const a = n == null ? void 0 : n.call(this);\n      r.call(this, o), this.requestUpdate(t, a, s);\n    }, configurable: !0, enumerable: !0 };\n  }\n  static getPropertyOptions(t) {\n    return this.elementProperties.get(t) ?? ln;\n  }\n  static _$Ei() {\n    if (this.hasOwnProperty(Ut(\"elementProperties\")))\n      return;\n    const t = _r(this);\n    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);\n  }\n  static finalize() {\n    if (this.hasOwnProperty(Ut(\"finalized\")))\n      return;\n    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Ut(\"properties\"))) {\n      const e = this.properties, s = [...vr(e), ...yr(e)];\n      for (const n of s)\n        this.createProperty(n, e[n]);\n    }\n    const t = this[Symbol.metadata];\n    if (t !== null) {\n      const e = litPropertyMetadata.get(t);\n      if (e !== void 0)\n        for (const [s, n] of e)\n          this.elementProperties.set(s, n);\n    }\n    this._$Eh = /* @__PURE__ */ new Map();\n    for (const [e, s] of this.elementProperties) {\n      const n = this._$Eu(e, s);\n      n !== void 0 && this._$Eh.set(n, e);\n    }\n    this.elementStyles = this.finalizeStyles(this.styles);\n  }\n  static finalizeStyles(t) {\n    const e = [];\n    if (Array.isArray(t)) {\n      const s = new Set(t.flat(1 / 0).reverse());\n      for (const n of s)\n        e.unshift(rn(n));\n    } else\n      t !== void 0 && e.push(rn(t));\n    return e;\n  }\n  static _$Eu(t, e) {\n    const s = e.attribute;\n    return s === !1 ? void 0 : typeof s == \"string\" ? s : typeof t == \"string\" ? t.toLowerCase() : void 0;\n  }\n  constructor() {\n    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();\n  }\n  _$Ev() {\n    var t;\n    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));\n  }\n  addController(t) {\n    var e;\n    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));\n  }\n  removeController(t) {\n    var e;\n    (e = this._$EO) == null || e.delete(t);\n  }\n  _$E_() {\n    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;\n    for (const s of e.keys())\n      this.hasOwnProperty(s) && (t.set(s, this[s]), delete this[s]);\n    t.size > 0 && (this._$Ep = t);\n  }\n  createRenderRoot() {\n    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);\n    return pr(t, this.constructor.elementStyles), t;\n  }\n  connectedCallback() {\n    var t;\n    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {\n      var s;\n      return (s = e.hostConnected) == null ? void 0 : s.call(e);\n    });\n  }\n  enableUpdating(t) {\n  }\n  disconnectedCallback() {\n    var t;\n    (t = this._$EO) == null || t.forEach((e) => {\n      var s;\n      return (s = e.hostDisconnected) == null ? void 0 : s.call(e);\n    });\n  }\n  attributeChangedCallback(t, e, s) {\n    this._$AK(t, s);\n  }\n  _$EC(t, e) {\n    var r;\n    const s = this.constructor.elementProperties.get(t), n = this.constructor._$Eu(t, s);\n    if (n !== void 0 && s.reflect === !0) {\n      const o = (((r = s.converter) == null ? void 0 : r.toAttribute) !== void 0 ? s.converter : we).toAttribute(e, s.type);\n      this._$Em = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$Em = null;\n    }\n  }\n  _$AK(t, e) {\n    var r;\n    const s = this.constructor, n = s._$Eh.get(t);\n    if (n !== void 0 && this._$Em !== n) {\n      const o = s.getPropertyOptions(n), a = typeof o.converter == \"function\" ? { fromAttribute: o.converter } : ((r = o.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? o.converter : we;\n      this._$Em = n, this[n] = a.fromAttribute(e, o.type), this._$Em = null;\n    }\n  }\n  requestUpdate(t, e, s) {\n    if (t !== void 0) {\n      if (s ?? (s = this.constructor.getPropertyOptions(t)), !(s.hasChanged ?? _i)(this[t], e))\n        return;\n      this.P(t, e, s);\n    }\n    this.isUpdatePending === !1 && (this._$ES = this._$ET());\n  }\n  P(t, e, s) {\n    this._$AL.has(t) || this._$AL.set(t, e), s.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);\n  }\n  async _$ET() {\n    this.isUpdatePending = !0;\n    try {\n      await this._$ES;\n    } catch (e) {\n      Promise.reject(e);\n    }\n    const t = this.scheduleUpdate();\n    return t != null && await t, !this.isUpdatePending;\n  }\n  scheduleUpdate() {\n    return this.performUpdate();\n  }\n  performUpdate() {\n    var s;\n    if (!this.isUpdatePending)\n      return;\n    if (!this.hasUpdated) {\n      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {\n        for (const [r, o] of this._$Ep)\n          this[r] = o;\n        this._$Ep = void 0;\n      }\n      const n = this.constructor.elementProperties;\n      if (n.size > 0)\n        for (const [r, o] of n)\n          o.wrapped !== !0 || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], o);\n    }\n    let t = !1;\n    const e = this._$AL;\n    try {\n      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (s = this._$EO) == null || s.forEach((n) => {\n        var r;\n        return (r = n.hostUpdate) == null ? void 0 : r.call(n);\n      }), this.update(e)) : this._$EU();\n    } catch (n) {\n      throw t = !1, this._$EU(), n;\n    }\n    t && this._$AE(e);\n  }\n  willUpdate(t) {\n  }\n  _$AE(t) {\n    var e;\n    (e = this._$EO) == null || e.forEach((s) => {\n      var n;\n      return (n = s.hostUpdated) == null ? void 0 : n.call(s);\n    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);\n  }\n  _$EU() {\n    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;\n  }\n  get updateComplete() {\n    return this.getUpdateComplete();\n  }\n  getUpdateComplete() {\n    return this._$ES;\n  }\n  shouldUpdate(t) {\n    return !0;\n  }\n  update(t) {\n    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();\n  }\n  updated(t) {\n  }\n  firstUpdated(t) {\n  }\n}\nkt.elementStyles = [], kt.shadowRootOptions = { mode: \"open\" }, kt[Ut(\"elementProperties\")] = /* @__PURE__ */ new Map(), kt[Ut(\"finalized\")] = /* @__PURE__ */ new Map(), We == null || We({ ReactiveElement: kt }), (it.reactiveElementVersions ?? (it.reactiveElementVersions = [])).push(\"2.0.4\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst qt = globalThis, $e = qt.trustedTypes, an = $e ? $e.createPolicy(\"lit-html\", { createHTML: (i) => i }) : void 0, es = \"$lit$\", et = `lit$${Math.random().toFixed(9).slice(2)}$`, is = \"?\" + et, wr = `<${is}>`, $t = document, Xt = () => $t.createComment(\"\"), Jt = (i) => i === null || typeof i != \"object\" && typeof i != \"function\", ns = Array.isArray, $r = (i) => ns(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == \"function\", Qe = `[ \t\n\\f\\r]`, Ft = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g, cn = /-->/g, un = />/g, _t = RegExp(`>|${Qe}(?:([^\\\\s\"'>=/]+)(${Qe}*=${Qe}*(?:[^ \t\n\\f\\r\"'\\`<>=]|(\"|')|))|$)`, \"g\"), hn = /'/g, dn = /\"/g, ss = /^(?:script|style|textarea|title)$/i, Cr = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e }), m = Cr(1), Ct = Symbol.for(\"lit-noChange\"), k = Symbol.for(\"lit-nothing\"), fn = /* @__PURE__ */ new WeakMap(), xt = $t.createTreeWalker($t, 129);\nfunction rs(i, t) {\n  if (!Array.isArray(i) || !i.hasOwnProperty(\"raw\"))\n    throw Error(\"invalid template strings array\");\n  return an !== void 0 ? an.createHTML(t) : t;\n}\nconst Er = (i, t) => {\n  const e = i.length - 1, s = [];\n  let n, r = t === 2 ? \"<svg>\" : \"\", o = Ft;\n  for (let a = 0; a < e; a++) {\n    const l = i[a];\n    let c, u, h = -1, f = 0;\n    for (; f < l.length && (o.lastIndex = f, u = o.exec(l), u !== null); )\n      f = o.lastIndex, o === Ft ? u[1] === \"!--\" ? o = cn : u[1] !== void 0 ? o = un : u[2] !== void 0 ? (ss.test(u[2]) && (n = RegExp(\"</\" + u[2], \"g\")), o = _t) : u[3] !== void 0 && (o = _t) : o === _t ? u[0] === \">\" ? (o = n ?? Ft, h = -1) : u[1] === void 0 ? h = -2 : (h = o.lastIndex - u[2].length, c = u[1], o = u[3] === void 0 ? _t : u[3] === '\"' ? dn : hn) : o === dn || o === hn ? o = _t : o === cn || o === un ? o = Ft : (o = _t, n = void 0);\n    const p = o === _t && i[a + 1].startsWith(\"/>\") ? \" \" : \"\";\n    r += o === Ft ? l + wr : h >= 0 ? (s.push(c), l.slice(0, h) + es + l.slice(h) + et + p) : l + et + (h === -2 ? a : p);\n  }\n  return [rs(i, r + (i[e] || \"<?>\") + (t === 2 ? \"</svg>\" : \"\")), s];\n};\nclass Kt {\n  constructor({ strings: t, _$litType$: e }, s) {\n    let n;\n    this.parts = [];\n    let r = 0, o = 0;\n    const a = t.length - 1, l = this.parts, [c, u] = Er(t, e);\n    if (this.el = Kt.createElement(c, s), xt.currentNode = this.el.content, e === 2) {\n      const h = this.el.content.firstChild;\n      h.replaceWith(...h.childNodes);\n    }\n    for (; (n = xt.nextNode()) !== null && l.length < a; ) {\n      if (n.nodeType === 1) {\n        if (n.hasAttributes())\n          for (const h of n.getAttributeNames())\n            if (h.endsWith(es)) {\n              const f = u[o++], p = n.getAttribute(h).split(et), b = /([.?@])?(.*)/.exec(f);\n              l.push({ type: 1, index: r, name: b[2], strings: p, ctor: b[1] === \".\" ? Sr : b[1] === \"?\" ? Or : b[1] === \"@\" ? kr : Be }), n.removeAttribute(h);\n            } else\n              h.startsWith(et) && (l.push({ type: 6, index: r }), n.removeAttribute(h));\n        if (ss.test(n.tagName)) {\n          const h = n.textContent.split(et), f = h.length - 1;\n          if (f > 0) {\n            n.textContent = $e ? $e.emptyScript : \"\";\n            for (let p = 0; p < f; p++)\n              n.append(h[p], Xt()), xt.nextNode(), l.push({ type: 2, index: ++r });\n            n.append(h[f], Xt());\n          }\n        }\n      } else if (n.nodeType === 8)\n        if (n.data === is)\n          l.push({ type: 2, index: r });\n        else {\n          let h = -1;\n          for (; (h = n.data.indexOf(et, h + 1)) !== -1; )\n            l.push({ type: 7, index: r }), h += et.length - 1;\n        }\n      r++;\n    }\n  }\n  static createElement(t, e) {\n    const s = $t.createElement(\"template\");\n    return s.innerHTML = t, s;\n  }\n}\nfunction zt(i, t, e = i, s) {\n  var o, a;\n  if (t === Ct)\n    return t;\n  let n = s !== void 0 ? (o = e._$Co) == null ? void 0 : o[s] : e._$Cl;\n  const r = Jt(t) ? void 0 : t._$litDirective$;\n  return (n == null ? void 0 : n.constructor) !== r && ((a = n == null ? void 0 : n._$AO) == null || a.call(n, !1), r === void 0 ? n = void 0 : (n = new r(i), n._$AT(i, e, s)), s !== void 0 ? (e._$Co ?? (e._$Co = []))[s] = n : e._$Cl = n), n !== void 0 && (t = zt(i, n._$AS(i, t.values), n, s)), t;\n}\nclass Ar {\n  constructor(t, e) {\n    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;\n  }\n  get parentNode() {\n    return this._$AM.parentNode;\n  }\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n  u(t) {\n    const { el: { content: e }, parts: s } = this._$AD, n = ((t == null ? void 0 : t.creationScope) ?? $t).importNode(e, !0);\n    xt.currentNode = n;\n    let r = xt.nextNode(), o = 0, a = 0, l = s[0];\n    for (; l !== void 0; ) {\n      if (o === l.index) {\n        let c;\n        l.type === 2 ? c = new oe(r, r.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (c = new Pr(r, this, t)), this._$AV.push(c), l = s[++a];\n      }\n      o !== (l == null ? void 0 : l.index) && (r = xt.nextNode(), o++);\n    }\n    return xt.currentNode = $t, n;\n  }\n  p(t) {\n    let e = 0;\n    for (const s of this._$AV)\n      s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++;\n  }\n}\nclass oe {\n  get _$AU() {\n    var t;\n    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;\n  }\n  constructor(t, e, s, n) {\n    this.type = 2, this._$AH = k, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = n, this._$Cv = (n == null ? void 0 : n.isConnected) ?? !0;\n  }\n  get parentNode() {\n    let t = this._$AA.parentNode;\n    const e = this._$AM;\n    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;\n  }\n  get startNode() {\n    return this._$AA;\n  }\n  get endNode() {\n    return this._$AB;\n  }\n  _$AI(t, e = this) {\n    t = zt(this, t, e), Jt(t) ? t === k || t == null || t === \"\" ? (this._$AH !== k && this._$AR(), this._$AH = k) : t !== this._$AH && t !== Ct && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : $r(t) ? this.k(t) : this._(t);\n  }\n  S(t) {\n    return this._$AA.parentNode.insertBefore(t, this._$AB);\n  }\n  T(t) {\n    this._$AH !== t && (this._$AR(), this._$AH = this.S(t));\n  }\n  _(t) {\n    this._$AH !== k && Jt(this._$AH) ? this._$AA.nextSibling.data = t : this.T($t.createTextNode(t)), this._$AH = t;\n  }\n  $(t) {\n    var r;\n    const { values: e, _$litType$: s } = t, n = typeof s == \"number\" ? this._$AC(t) : (s.el === void 0 && (s.el = Kt.createElement(rs(s.h, s.h[0]), this.options)), s);\n    if (((r = this._$AH) == null ? void 0 : r._$AD) === n)\n      this._$AH.p(e);\n    else {\n      const o = new Ar(n, this), a = o.u(this.options);\n      o.p(e), this.T(a), this._$AH = o;\n    }\n  }\n  _$AC(t) {\n    let e = fn.get(t.strings);\n    return e === void 0 && fn.set(t.strings, e = new Kt(t)), e;\n  }\n  k(t) {\n    ns(this._$AH) || (this._$AH = [], this._$AR());\n    const e = this._$AH;\n    let s, n = 0;\n    for (const r of t)\n      n === e.length ? e.push(s = new oe(this.S(Xt()), this.S(Xt()), this, this.options)) : s = e[n], s._$AI(r), n++;\n    n < e.length && (this._$AR(s && s._$AB.nextSibling, n), e.length = n);\n  }\n  _$AR(t = this._$AA.nextSibling, e) {\n    var s;\n    for ((s = this._$AP) == null ? void 0 : s.call(this, !1, !0, e); t && t !== this._$AB; ) {\n      const n = t.nextSibling;\n      t.remove(), t = n;\n    }\n  }\n  setConnected(t) {\n    var e;\n    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));\n  }\n}\nclass Be {\n  get tagName() {\n    return this.element.tagName;\n  }\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n  constructor(t, e, s, n, r) {\n    this.type = 1, this._$AH = k, this._$AN = void 0, this.element = t, this.name = e, this._$AM = n, this.options = r, s.length > 2 || s[0] !== \"\" || s[1] !== \"\" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = k;\n  }\n  _$AI(t, e = this, s, n) {\n    const r = this.strings;\n    let o = !1;\n    if (r === void 0)\n      t = zt(this, t, e, 0), o = !Jt(t) || t !== this._$AH && t !== Ct, o && (this._$AH = t);\n    else {\n      const a = t;\n      let l, c;\n      for (t = r[0], l = 0; l < r.length - 1; l++)\n        c = zt(this, a[s + l], e, l), c === Ct && (c = this._$AH[l]), o || (o = !Jt(c) || c !== this._$AH[l]), c === k ? t = k : t !== k && (t += (c ?? \"\") + r[l + 1]), this._$AH[l] = c;\n    }\n    o && !n && this.j(t);\n  }\n  j(t) {\n    t === k ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? \"\");\n  }\n}\nclass Sr extends Be {\n  constructor() {\n    super(...arguments), this.type = 3;\n  }\n  j(t) {\n    this.element[this.name] = t === k ? void 0 : t;\n  }\n}\nclass Or extends Be {\n  constructor() {\n    super(...arguments), this.type = 4;\n  }\n  j(t) {\n    this.element.toggleAttribute(this.name, !!t && t !== k);\n  }\n}\nclass kr extends Be {\n  constructor(t, e, s, n, r) {\n    super(t, e, s, n, r), this.type = 5;\n  }\n  _$AI(t, e = this) {\n    if ((t = zt(this, t, e, 0) ?? k) === Ct)\n      return;\n    const s = this._$AH, n = t === k && s !== k || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, r = t !== k && (s === k || n);\n    n && this.element.removeEventListener(this.name, this, s), r && this.element.addEventListener(this.name, this, t), this._$AH = t;\n  }\n  handleEvent(t) {\n    var e;\n    typeof this._$AH == \"function\" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);\n  }\n}\nclass Pr {\n  constructor(t, e, s) {\n    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s;\n  }\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n  _$AI(t) {\n    zt(this, t);\n  }\n}\nconst Ye = qt.litHtmlPolyfillSupport;\nYe == null || Ye(Kt, oe), (qt.litHtmlVersions ?? (qt.litHtmlVersions = [])).push(\"3.1.3\");\nconst Rt = (i, t, e) => {\n  const s = (e == null ? void 0 : e.renderBefore) ?? t;\n  let n = s._$litPart$;\n  if (n === void 0) {\n    const r = (e == null ? void 0 : e.renderBefore) ?? null;\n    s._$litPart$ = n = new oe(t.insertBefore(Xt(), r), r, void 0, e ?? {});\n  }\n  return n._$AI(i), n;\n};\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet w = class extends kt {\n  constructor() {\n    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;\n  }\n  createRenderRoot() {\n    var e;\n    const t = super.createRenderRoot();\n    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;\n  }\n  update(t) {\n    const e = this.render();\n    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Rt(e, this.renderRoot, this.renderOptions);\n  }\n  connectedCallback() {\n    var t;\n    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);\n  }\n  disconnectedCallback() {\n    var t;\n    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);\n  }\n  render() {\n    return Ct;\n  }\n};\nvar zn;\nw._$litElement$ = !0, w.finalized = !0, (zn = globalThis.litElementHydrateSupport) == null || zn.call(globalThis, { LitElement: w });\nconst Ge = globalThis.litElementPolyfillSupport;\nGe == null || Ge({ LitElement: w });\n(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push(\"4.0.5\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst Tr = { attribute: !0, type: String, converter: we, reflect: !1, hasChanged: _i }, Lr = (i = Tr, t, e) => {\n  const { kind: s, metadata: n } = e;\n  let r = globalThis.litPropertyMetadata.get(n);\n  if (r === void 0 && globalThis.litPropertyMetadata.set(n, r = /* @__PURE__ */ new Map()), r.set(e.name, i), s === \"accessor\") {\n    const { name: o } = e;\n    return { set(a) {\n      const l = t.get.call(this);\n      t.set.call(this, a), this.requestUpdate(o, l, i);\n    }, init(a) {\n      return a !== void 0 && this.P(o, void 0, i), a;\n    } };\n  }\n  if (s === \"setter\") {\n    const { name: o } = e;\n    return function(a) {\n      const l = this[o];\n      t.call(this, a), this.requestUpdate(o, l, i);\n    };\n  }\n  throw Error(\"Unsupported decorator location: \" + s);\n};\nfunction d(i) {\n  return (t, e) => typeof e == \"object\" ? Lr(i, t, e) : ((s, n, r) => {\n    const o = n.hasOwnProperty(r);\n    return n.constructor.createProperty(r, o ? { ...s, wrapped: !0 } : s), o ? Object.getOwnPropertyDescriptor(n, r) : void 0;\n  })(i, t, e);\n}\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nfunction le(i) {\n  return d({ ...i, state: !0, attribute: !1 });\n}\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst Ir = (i) => i.strings === void 0;\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst os = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, ls = (i) => (...t) => ({ _$litDirective$: i, values: t });\nlet as = class {\n  constructor(t) {\n  }\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n  _$AT(t, e, s) {\n    this._$Ct = t, this._$AM = e, this._$Ci = s;\n  }\n  _$AS(t, e) {\n    return this.update(t, e);\n  }\n  update(t, e) {\n    return this.render(...e);\n  }\n};\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst Wt = (i, t) => {\n  var s;\n  const e = i._$AN;\n  if (e === void 0)\n    return !1;\n  for (const n of e)\n    (s = n._$AO) == null || s.call(n, t, !1), Wt(n, t);\n  return !0;\n}, Ce = (i) => {\n  let t, e;\n  do {\n    if ((t = i._$AM) === void 0)\n      break;\n    e = t._$AN, e.delete(i), i = t;\n  } while ((e == null ? void 0 : e.size) === 0);\n}, cs = (i) => {\n  for (let t; t = i._$AM; i = t) {\n    let e = t._$AN;\n    if (e === void 0)\n      t._$AN = e = /* @__PURE__ */ new Set();\n    else if (e.has(i))\n      break;\n    e.add(i), Mr(t);\n  }\n};\nfunction zr(i) {\n  this._$AN !== void 0 ? (Ce(this), this._$AM = i, cs(this)) : this._$AM = i;\n}\nfunction Rr(i, t = !1, e = 0) {\n  const s = this._$AH, n = this._$AN;\n  if (n !== void 0 && n.size !== 0)\n    if (t)\n      if (Array.isArray(s))\n        for (let r = e; r < s.length; r++)\n          Wt(s[r], !1), Ce(s[r]);\n      else\n        s != null && (Wt(s, !1), Ce(s));\n    else\n      Wt(this, i);\n}\nconst Mr = (i) => {\n  i.type == os.CHILD && (i._$AP ?? (i._$AP = Rr), i._$AQ ?? (i._$AQ = zr));\n};\nclass jr extends as {\n  constructor() {\n    super(...arguments), this._$AN = void 0;\n  }\n  _$AT(t, e, s) {\n    super._$AT(t, e, s), cs(this), this.isConnected = t._$AU;\n  }\n  _$AO(t, e = !0) {\n    var s, n;\n    t !== this.isConnected && (this.isConnected = t, t ? (s = this.reconnected) == null || s.call(this) : (n = this.disconnected) == null || n.call(this)), e && (Wt(this, t), Ce(this));\n  }\n  setValue(t) {\n    if (Ir(this._$Ct))\n      this._$Ct._$AI(t, this);\n    else {\n      const e = [...this._$Ct._$AH];\n      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);\n    }\n  }\n  disconnected() {\n  }\n  reconnected() {\n  }\n}\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst nt = () => new Br();\nclass Br {\n}\nconst Xe = /* @__PURE__ */ new WeakMap(), st = ls(class extends jr {\n  render(i) {\n    return k;\n  }\n  update(i, [t]) {\n    var s;\n    const e = t !== this.Y;\n    return e && this.Y !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.Y = t, this.ht = (s = i.options) == null ? void 0 : s.host, this.rt(this.ct = i.element)), k;\n  }\n  rt(i) {\n    if (typeof this.Y == \"function\") {\n      const t = this.ht ?? globalThis;\n      let e = Xe.get(t);\n      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Xe.set(t, e)), e.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), e.set(this.Y, i), i !== void 0 && this.Y.call(this.ht, i);\n    } else\n      this.Y.value = i;\n  }\n  get lt() {\n    var i, t;\n    return typeof this.Y == \"function\" ? (i = Xe.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;\n  }\n  disconnected() {\n    this.lt === this.ct && this.rt(void 0);\n  }\n  reconnected() {\n    this.rt(this.ct);\n  }\n});\n/**\n* (c) Iconify\n*\n* For the full copyright and license information, please view the license.txt\n* files at https://github.com/iconify/iconify\n*\n* Licensed under MIT.\n*\n* @license MIT\n* @version 2.0.0\n*/\nconst us = Object.freeze(\n  {\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n  }\n), Ee = Object.freeze({\n  rotate: 0,\n  vFlip: !1,\n  hFlip: !1\n}), ae = Object.freeze({\n  ...us,\n  ...Ee\n}), ni = Object.freeze({\n  ...ae,\n  body: \"\",\n  hidden: !1\n}), Nr = Object.freeze({\n  width: null,\n  height: null\n}), hs = Object.freeze({\n  // Dimensions\n  ...Nr,\n  // Transformations\n  ...Ee\n});\nfunction Hr(i, t = 0) {\n  const e = i.replace(/^-?[0-9.]*/, \"\");\n  function s(n) {\n    for (; n < 0; )\n      n += 4;\n    return n % 4;\n  }\n  if (e === \"\") {\n    const n = parseInt(i);\n    return isNaN(n) ? 0 : s(n);\n  } else if (e !== i) {\n    let n = 0;\n    switch (e) {\n      case \"%\":\n        n = 25;\n        break;\n      case \"deg\":\n        n = 90;\n    }\n    if (n) {\n      let r = parseFloat(i.slice(0, i.length - e.length));\n      return isNaN(r) ? 0 : (r = r / n, r % 1 === 0 ? s(r) : 0);\n    }\n  }\n  return t;\n}\nconst Dr = /[\\s,]+/;\nfunction Fr(i, t) {\n  t.split(Dr).forEach((e) => {\n    switch (e.trim()) {\n      case \"horizontal\":\n        i.hFlip = !0;\n        break;\n      case \"vertical\":\n        i.vFlip = !0;\n        break;\n    }\n  });\n}\nconst ds = {\n  ...hs,\n  preserveAspectRatio: \"\"\n};\nfunction pn(i) {\n  const t = {\n    ...ds\n  }, e = (s, n) => i.getAttribute(s) || n;\n  return t.width = e(\"width\", null), t.height = e(\"height\", null), t.rotate = Hr(e(\"rotate\", \"\")), Fr(t, e(\"flip\", \"\")), t.preserveAspectRatio = e(\"preserveAspectRatio\", e(\"preserveaspectratio\", \"\")), t;\n}\nfunction Vr(i, t) {\n  for (const e in ds)\n    if (i[e] !== t[e])\n      return !0;\n  return !1;\n}\nconst Qt = /^[a-z0-9]+(-[a-z0-9]+)*$/, ce = (i, t, e, s = \"\") => {\n  const n = i.split(\":\");\n  if (i.slice(0, 1) === \"@\") {\n    if (n.length < 2 || n.length > 3)\n      return null;\n    s = n.shift().slice(1);\n  }\n  if (n.length > 3 || !n.length)\n    return null;\n  if (n.length > 1) {\n    const a = n.pop(), l = n.pop(), c = {\n      // Allow provider without '@': \"provider:prefix:name\"\n      provider: n.length > 0 ? n[0] : s,\n      prefix: l,\n      name: a\n    };\n    return t && !ve(c) ? null : c;\n  }\n  const r = n[0], o = r.split(\"-\");\n  if (o.length > 1) {\n    const a = {\n      provider: s,\n      prefix: o.shift(),\n      name: o.join(\"-\")\n    };\n    return t && !ve(a) ? null : a;\n  }\n  if (e && s === \"\") {\n    const a = {\n      provider: s,\n      prefix: \"\",\n      name: r\n    };\n    return t && !ve(a, e) ? null : a;\n  }\n  return null;\n}, ve = (i, t) => i ? !!((i.provider === \"\" || i.provider.match(Qt)) && (t && i.prefix === \"\" || i.prefix.match(Qt)) && i.name.match(Qt)) : !1;\nfunction Ur(i, t) {\n  const e = {};\n  !i.hFlip != !t.hFlip && (e.hFlip = !0), !i.vFlip != !t.vFlip && (e.vFlip = !0);\n  const s = ((i.rotate || 0) + (t.rotate || 0)) % 4;\n  return s && (e.rotate = s), e;\n}\nfunction mn(i, t) {\n  const e = Ur(i, t);\n  for (const s in ni)\n    s in Ee ? s in i && !(s in e) && (e[s] = Ee[s]) : s in t ? e[s] = t[s] : s in i && (e[s] = i[s]);\n  return e;\n}\nfunction qr(i, t) {\n  const e = i.icons, s = i.aliases || /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);\n  function r(o) {\n    if (e[o])\n      return n[o] = [];\n    if (!(o in n)) {\n      n[o] = null;\n      const a = s[o] && s[o].parent, l = a && r(a);\n      l && (n[o] = [a].concat(l));\n    }\n    return n[o];\n  }\n  return Object.keys(e).concat(Object.keys(s)).forEach(r), n;\n}\nfunction Wr(i, t, e) {\n  const s = i.icons, n = i.aliases || /* @__PURE__ */ Object.create(null);\n  let r = {};\n  function o(a) {\n    r = mn(\n      s[a] || n[a],\n      r\n    );\n  }\n  return o(t), e.forEach(o), mn(i, r);\n}\nfunction fs(i, t) {\n  const e = [];\n  if (typeof i != \"object\" || typeof i.icons != \"object\")\n    return e;\n  i.not_found instanceof Array && i.not_found.forEach((n) => {\n    t(n, null), e.push(n);\n  });\n  const s = qr(i);\n  for (const n in s) {\n    const r = s[n];\n    r && (t(n, Wr(i, n, r)), e.push(n));\n  }\n  return e;\n}\nconst Qr = {\n  provider: \"\",\n  aliases: {},\n  not_found: {},\n  ...us\n};\nfunction Je(i, t) {\n  for (const e in t)\n    if (e in i && typeof i[e] != typeof t[e])\n      return !1;\n  return !0;\n}\nfunction ps(i) {\n  if (typeof i != \"object\" || i === null)\n    return null;\n  const t = i;\n  if (typeof t.prefix != \"string\" || !i.icons || typeof i.icons != \"object\" || !Je(i, Qr))\n    return null;\n  const e = t.icons;\n  for (const n in e) {\n    const r = e[n];\n    if (!n.match(Qt) || typeof r.body != \"string\" || !Je(\n      r,\n      ni\n    ))\n      return null;\n  }\n  const s = t.aliases || /* @__PURE__ */ Object.create(null);\n  for (const n in s) {\n    const r = s[n], o = r.parent;\n    if (!n.match(Qt) || typeof o != \"string\" || !e[o] && !s[o] || !Je(\n      r,\n      ni\n    ))\n      return null;\n  }\n  return t;\n}\nconst Ae = /* @__PURE__ */ Object.create(null);\nfunction Yr(i, t) {\n  return {\n    provider: i,\n    prefix: t,\n    icons: /* @__PURE__ */ Object.create(null),\n    missing: /* @__PURE__ */ new Set()\n  };\n}\nfunction lt(i, t) {\n  const e = Ae[i] || (Ae[i] = /* @__PURE__ */ Object.create(null));\n  return e[t] || (e[t] = Yr(i, t));\n}\nfunction xi(i, t) {\n  return ps(t) ? fs(t, (e, s) => {\n    s ? i.icons[e] = s : i.missing.add(e);\n  }) : [];\n}\nfunction Gr(i, t, e) {\n  try {\n    if (typeof e.body == \"string\")\n      return i.icons[t] = { ...e }, !0;\n  } catch {\n  }\n  return !1;\n}\nfunction Xr(i, t) {\n  let e = [];\n  return (typeof i == \"string\" ? [i] : Object.keys(Ae)).forEach((n) => {\n    (typeof n == \"string\" && typeof t == \"string\" ? [t] : Object.keys(Ae[n] || {})).forEach((o) => {\n      const a = lt(n, o);\n      e = e.concat(\n        Object.keys(a.icons).map(\n          (l) => (n !== \"\" ? \"@\" + n + \":\" : \"\") + o + \":\" + l\n        )\n      );\n    });\n  }), e;\n}\nlet Zt = !1;\nfunction ms(i) {\n  return typeof i == \"boolean\" && (Zt = i), Zt;\n}\nfunction te(i) {\n  const t = typeof i == \"string\" ? ce(i, !0, Zt) : i;\n  if (t) {\n    const e = lt(t.provider, t.prefix), s = t.name;\n    return e.icons[s] || (e.missing.has(s) ? null : void 0);\n  }\n}\nfunction bs(i, t) {\n  const e = ce(i, !0, Zt);\n  if (!e)\n    return !1;\n  const s = lt(e.provider, e.prefix);\n  return Gr(s, e.name, t);\n}\nfunction bn(i, t) {\n  if (typeof i != \"object\")\n    return !1;\n  if (typeof t != \"string\" && (t = i.provider || \"\"), Zt && !t && !i.prefix) {\n    let n = !1;\n    return ps(i) && (i.prefix = \"\", fs(i, (r, o) => {\n      o && bs(r, o) && (n = !0);\n    })), n;\n  }\n  const e = i.prefix;\n  if (!ve({\n    provider: t,\n    prefix: e,\n    name: \"a\"\n  }))\n    return !1;\n  const s = lt(t, e);\n  return !!xi(s, i);\n}\nfunction gn(i) {\n  return !!te(i);\n}\nfunction Jr(i) {\n  const t = te(i);\n  return t ? {\n    ...ae,\n    ...t\n  } : null;\n}\nfunction Kr(i) {\n  const t = {\n    loaded: [],\n    missing: [],\n    pending: []\n  }, e = /* @__PURE__ */ Object.create(null);\n  i.sort((n, r) => n.provider !== r.provider ? n.provider.localeCompare(r.provider) : n.prefix !== r.prefix ? n.prefix.localeCompare(r.prefix) : n.name.localeCompare(r.name));\n  let s = {\n    provider: \"\",\n    prefix: \"\",\n    name: \"\"\n  };\n  return i.forEach((n) => {\n    if (s.name === n.name && s.prefix === n.prefix && s.provider === n.provider)\n      return;\n    s = n;\n    const r = n.provider, o = n.prefix, a = n.name, l = e[r] || (e[r] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = lt(r, o));\n    let u;\n    a in c.icons ? u = t.loaded : o === \"\" || c.missing.has(a) ? u = t.missing : u = t.pending;\n    const h = {\n      provider: r,\n      prefix: o,\n      name: a\n    };\n    u.push(h);\n  }), t;\n}\nfunction gs(i, t) {\n  i.forEach((e) => {\n    const s = e.loaderCallbacks;\n    s && (e.loaderCallbacks = s.filter((n) => n.id !== t));\n  });\n}\nfunction Zr(i) {\n  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = !0, setTimeout(() => {\n    i.pendingCallbacksFlag = !1;\n    const t = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];\n    if (!t.length)\n      return;\n    let e = !1;\n    const s = i.provider, n = i.prefix;\n    t.forEach((r) => {\n      const o = r.icons, a = o.pending.length;\n      o.pending = o.pending.filter((l) => {\n        if (l.prefix !== n)\n          return !0;\n        const c = l.name;\n        if (i.icons[c])\n          o.loaded.push({\n            provider: s,\n            prefix: n,\n            name: c\n          });\n        else if (i.missing.has(c))\n          o.missing.push({\n            provider: s,\n            prefix: n,\n            name: c\n          });\n        else\n          return e = !0, !0;\n        return !1;\n      }), o.pending.length !== a && (e || gs([i], r.id), r.callback(\n        o.loaded.slice(0),\n        o.missing.slice(0),\n        o.pending.slice(0),\n        r.abort\n      ));\n    });\n  }));\n}\nlet to = 0;\nfunction eo(i, t, e) {\n  const s = to++, n = gs.bind(null, e, s);\n  if (!t.pending.length)\n    return n;\n  const r = {\n    id: s,\n    icons: t,\n    callback: i,\n    abort: n\n  };\n  return e.forEach((o) => {\n    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(r);\n  }), n;\n}\nconst si = /* @__PURE__ */ Object.create(null);\nfunction vn(i, t) {\n  si[i] = t;\n}\nfunction ri(i) {\n  return si[i] || si[\"\"];\n}\nfunction io(i, t = !0, e = !1) {\n  const s = [];\n  return i.forEach((n) => {\n    const r = typeof n == \"string\" ? ce(n, t, e) : n;\n    r && s.push(r);\n  }), s;\n}\nvar no = {\n  resources: [],\n  index: 0,\n  timeout: 2e3,\n  rotate: 750,\n  random: !1,\n  dataAfterTimeout: !1\n};\nfunction so(i, t, e, s) {\n  const n = i.resources.length, r = i.random ? Math.floor(Math.random() * n) : i.index;\n  let o;\n  if (i.random) {\n    let y = i.resources.slice(0);\n    for (o = []; y.length > 1; ) {\n      const T = Math.floor(Math.random() * y.length);\n      o.push(y[T]), y = y.slice(0, T).concat(y.slice(T + 1));\n    }\n    o = o.concat(y);\n  } else\n    o = i.resources.slice(r).concat(i.resources.slice(0, r));\n  const a = Date.now();\n  let l = \"pending\", c = 0, u, h = null, f = [], p = [];\n  typeof s == \"function\" && p.push(s);\n  function b() {\n    h && (clearTimeout(h), h = null);\n  }\n  function v() {\n    l === \"pending\" && (l = \"aborted\"), b(), f.forEach((y) => {\n      y.status === \"pending\" && (y.status = \"aborted\");\n    }), f = [];\n  }\n  function g(y, T) {\n    T && (p = []), typeof y == \"function\" && p.push(y);\n  }\n  function A() {\n    return {\n      startTime: a,\n      payload: t,\n      status: l,\n      queriesSent: c,\n      queriesPending: f.length,\n      subscribe: g,\n      abort: v\n    };\n  }\n  function E() {\n    l = \"failed\", p.forEach((y) => {\n      y(void 0, u);\n    });\n  }\n  function x() {\n    f.forEach((y) => {\n      y.status === \"pending\" && (y.status = \"aborted\");\n    }), f = [];\n  }\n  function $(y, T, z) {\n    const q = T !== \"success\";\n    switch (f = f.filter((O) => O !== y), l) {\n      case \"pending\":\n        break;\n      case \"failed\":\n        if (q || !i.dataAfterTimeout)\n          return;\n        break;\n      default:\n        return;\n    }\n    if (T === \"abort\") {\n      u = z, E();\n      return;\n    }\n    if (q) {\n      u = z, f.length || (o.length ? S() : E());\n      return;\n    }\n    if (b(), x(), !i.random) {\n      const O = i.resources.indexOf(y.resource);\n      O !== -1 && O !== i.index && (i.index = O);\n    }\n    l = \"completed\", p.forEach((O) => {\n      O(z);\n    });\n  }\n  function S() {\n    if (l !== \"pending\")\n      return;\n    b();\n    const y = o.shift();\n    if (y === void 0) {\n      if (f.length) {\n        h = setTimeout(() => {\n          b(), l === \"pending\" && (x(), E());\n        }, i.timeout);\n        return;\n      }\n      E();\n      return;\n    }\n    const T = {\n      status: \"pending\",\n      resource: y,\n      callback: (z, q) => {\n        $(T, z, q);\n      }\n    };\n    f.push(T), c++, h = setTimeout(S, i.rotate), e(y, t, T.callback);\n  }\n  return setTimeout(S), A;\n}\nfunction vs(i) {\n  const t = {\n    ...no,\n    ...i\n  };\n  let e = [];\n  function s() {\n    e = e.filter((a) => a().status === \"pending\");\n  }\n  function n(a, l, c) {\n    const u = so(\n      t,\n      a,\n      l,\n      (h, f) => {\n        s(), c && c(h, f);\n      }\n    );\n    return e.push(u), u;\n  }\n  function r(a) {\n    return e.find((l) => a(l)) || null;\n  }\n  return {\n    query: n,\n    find: r,\n    setIndex: (a) => {\n      t.index = a;\n    },\n    getIndex: () => t.index,\n    cleanup: s\n  };\n}\nfunction wi(i) {\n  let t;\n  if (typeof i.resources == \"string\")\n    t = [i.resources];\n  else if (t = i.resources, !(t instanceof Array) || !t.length)\n    return null;\n  return {\n    // API hosts\n    resources: t,\n    // Root path\n    path: i.path || \"/\",\n    // URL length limit\n    maxURL: i.maxURL || 500,\n    // Timeout before next host is used.\n    rotate: i.rotate || 750,\n    // Timeout before failing query.\n    timeout: i.timeout || 5e3,\n    // Randomise default API end point.\n    random: i.random === !0,\n    // Start index\n    index: i.index || 0,\n    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n    dataAfterTimeout: i.dataAfterTimeout !== !1\n  };\n}\nconst Ne = /* @__PURE__ */ Object.create(null), Vt = [\n  \"https://api.simplesvg.com\",\n  \"https://api.unisvg.com\"\n], ye = [];\nfor (; Vt.length > 0; )\n  Vt.length === 1 || Math.random() > 0.5 ? ye.push(Vt.shift()) : ye.push(Vt.pop());\nNe[\"\"] = wi({\n  resources: [\"https://api.iconify.design\"].concat(ye)\n});\nfunction yn(i, t) {\n  const e = wi(t);\n  return e === null ? !1 : (Ne[i] = e, !0);\n}\nfunction He(i) {\n  return Ne[i];\n}\nfunction ro() {\n  return Object.keys(Ne);\n}\nfunction _n() {\n}\nconst Ke = /* @__PURE__ */ Object.create(null);\nfunction oo(i) {\n  if (!Ke[i]) {\n    const t = He(i);\n    if (!t)\n      return;\n    const e = vs(t), s = {\n      config: t,\n      redundancy: e\n    };\n    Ke[i] = s;\n  }\n  return Ke[i];\n}\nfunction ys(i, t, e) {\n  let s, n;\n  if (typeof i == \"string\") {\n    const r = ri(i);\n    if (!r)\n      return e(void 0, 424), _n;\n    n = r.send;\n    const o = oo(i);\n    o && (s = o.redundancy);\n  } else {\n    const r = wi(i);\n    if (r) {\n      s = vs(r);\n      const o = i.resources ? i.resources[0] : \"\", a = ri(o);\n      a && (n = a.send);\n    }\n  }\n  return !s || !n ? (e(void 0, 424), _n) : s.query(t, n, e)().abort;\n}\nconst xn = \"iconify2\", ee = \"iconify\", _s = ee + \"-count\", wn = ee + \"-version\", xs = 36e5, lo = 168, ao = 50;\nfunction oi(i, t) {\n  try {\n    return i.getItem(t);\n  } catch {\n  }\n}\nfunction $i(i, t, e) {\n  try {\n    return i.setItem(t, e), !0;\n  } catch {\n  }\n}\nfunction $n(i, t) {\n  try {\n    i.removeItem(t);\n  } catch {\n  }\n}\nfunction li(i, t) {\n  return $i(i, _s, t.toString());\n}\nfunction ai(i) {\n  return parseInt(oi(i, _s)) || 0;\n}\nconst wt = {\n  local: !0,\n  session: !0\n}, ws = {\n  local: /* @__PURE__ */ new Set(),\n  session: /* @__PURE__ */ new Set()\n};\nlet Ci = !1;\nfunction co(i) {\n  Ci = i;\n}\nlet be = typeof window > \"u\" ? {} : window;\nfunction $s(i) {\n  const t = i + \"Storage\";\n  try {\n    if (be && be[t] && typeof be[t].length == \"number\")\n      return be[t];\n  } catch {\n  }\n  wt[i] = !1;\n}\nfunction Cs(i, t) {\n  const e = $s(i);\n  if (!e)\n    return;\n  const s = oi(e, wn);\n  if (s !== xn) {\n    if (s) {\n      const a = ai(e);\n      for (let l = 0; l < a; l++)\n        $n(e, ee + l.toString());\n    }\n    $i(e, wn, xn), li(e, 0);\n    return;\n  }\n  const n = Math.floor(Date.now() / xs) - lo, r = (a) => {\n    const l = ee + a.toString(), c = oi(e, l);\n    if (typeof c == \"string\") {\n      try {\n        const u = JSON.parse(c);\n        if (typeof u == \"object\" && typeof u.cached == \"number\" && u.cached > n && typeof u.provider == \"string\" && typeof u.data == \"object\" && typeof u.data.prefix == \"string\" && // Valid item: run callback\n        t(u, a))\n          return !0;\n      } catch {\n      }\n      $n(e, l);\n    }\n  };\n  let o = ai(e);\n  for (let a = o - 1; a >= 0; a--)\n    r(a) || (a === o - 1 ? (o--, li(e, o)) : ws[i].add(a));\n}\nfunction Es() {\n  if (!Ci) {\n    co(!0);\n    for (const i in wt)\n      Cs(i, (t) => {\n        const e = t.data, s = t.provider, n = e.prefix, r = lt(\n          s,\n          n\n        );\n        if (!xi(r, e).length)\n          return !1;\n        const o = e.lastModified || -1;\n        return r.lastModifiedCached = r.lastModifiedCached ? Math.min(r.lastModifiedCached, o) : o, !0;\n      });\n  }\n}\nfunction uo(i, t) {\n  const e = i.lastModifiedCached;\n  if (\n    // Matches or newer\n    e && e >= t\n  )\n    return e === t;\n  if (i.lastModifiedCached = t, e)\n    for (const s in wt)\n      Cs(s, (n) => {\n        const r = n.data;\n        return n.provider !== i.provider || r.prefix !== i.prefix || r.lastModified === t;\n      });\n  return !0;\n}\nfunction ho(i, t) {\n  Ci || Es();\n  function e(s) {\n    let n;\n    if (!wt[s] || !(n = $s(s)))\n      return;\n    const r = ws[s];\n    let o;\n    if (r.size)\n      r.delete(o = Array.from(r).shift());\n    else if (o = ai(n), o >= ao || !li(n, o + 1))\n      return;\n    const a = {\n      cached: Math.floor(Date.now() / xs),\n      provider: i.provider,\n      data: t\n    };\n    return $i(\n      n,\n      ee + o.toString(),\n      JSON.stringify(a)\n    );\n  }\n  t.lastModified && !uo(i, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), e(\"local\") || e(\"session\"));\n}\nfunction Cn() {\n}\nfunction fo(i) {\n  i.iconsLoaderFlag || (i.iconsLoaderFlag = !0, setTimeout(() => {\n    i.iconsLoaderFlag = !1, Zr(i);\n  }));\n}\nfunction po(i, t) {\n  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(t).sort() : i.iconsToLoad = t, i.iconsQueueFlag || (i.iconsQueueFlag = !0, setTimeout(() => {\n    i.iconsQueueFlag = !1;\n    const { provider: e, prefix: s } = i, n = i.iconsToLoad;\n    delete i.iconsToLoad;\n    let r;\n    if (!n || !(r = ri(e)))\n      return;\n    r.prepare(e, s, n).forEach((a) => {\n      ys(e, a, (l) => {\n        if (typeof l != \"object\")\n          a.icons.forEach((c) => {\n            i.missing.add(c);\n          });\n        else\n          try {\n            const c = xi(\n              i,\n              l\n            );\n            if (!c.length)\n              return;\n            const u = i.pendingIcons;\n            u && c.forEach((h) => {\n              u.delete(h);\n            }), ho(i, l);\n          } catch (c) {\n            console.error(c);\n          }\n        fo(i);\n      });\n    });\n  }));\n}\nconst Ei = (i, t) => {\n  const e = io(i, !0, ms()), s = Kr(e);\n  if (!s.pending.length) {\n    let l = !0;\n    return t && setTimeout(() => {\n      l && t(\n        s.loaded,\n        s.missing,\n        s.pending,\n        Cn\n      );\n    }), () => {\n      l = !1;\n    };\n  }\n  const n = /* @__PURE__ */ Object.create(null), r = [];\n  let o, a;\n  return s.pending.forEach((l) => {\n    const { provider: c, prefix: u } = l;\n    if (u === a && c === o)\n      return;\n    o = c, a = u, r.push(lt(c, u));\n    const h = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));\n    h[u] || (h[u] = []);\n  }), s.pending.forEach((l) => {\n    const { provider: c, prefix: u, name: h } = l, f = lt(c, u), p = f.pendingIcons || (f.pendingIcons = /* @__PURE__ */ new Set());\n    p.has(h) || (p.add(h), n[c][u].push(h));\n  }), r.forEach((l) => {\n    const { provider: c, prefix: u } = l;\n    n[c][u].length && po(l, n[c][u]);\n  }), t ? eo(t, s, r) : Cn;\n}, mo = (i) => new Promise((t, e) => {\n  const s = typeof i == \"string\" ? ce(i, !0) : i;\n  if (!s) {\n    e(i);\n    return;\n  }\n  Ei([s || i], (n) => {\n    if (n.length && s) {\n      const r = te(s);\n      if (r) {\n        t({\n          ...ae,\n          ...r\n        });\n        return;\n      }\n    }\n    e(i);\n  });\n});\nfunction bo(i) {\n  try {\n    const t = typeof i == \"string\" ? JSON.parse(i) : i;\n    if (typeof t.body == \"string\")\n      return {\n        ...t\n      };\n  } catch {\n  }\n}\nfunction go(i, t) {\n  const e = typeof i == \"string\" ? ce(i, !0, !0) : null;\n  if (!e) {\n    const r = bo(i);\n    return {\n      value: i,\n      data: r\n    };\n  }\n  const s = te(e);\n  if (s !== void 0 || !e.prefix)\n    return {\n      value: i,\n      name: e,\n      data: s\n      // could be 'null' -> icon is missing\n    };\n  const n = Ei([e], () => t(i, e, te(e)));\n  return {\n    value: i,\n    name: e,\n    loading: n\n  };\n}\nfunction Ze(i) {\n  return i.hasAttribute(\"inline\");\n}\nlet As = !1;\ntry {\n  As = navigator.vendor.indexOf(\"Apple\") === 0;\n} catch {\n}\nfunction vo(i, t) {\n  switch (t) {\n    case \"svg\":\n    case \"bg\":\n    case \"mask\":\n      return t;\n  }\n  return t !== \"style\" && (As || i.indexOf(\"<a\") === -1) ? \"svg\" : i.indexOf(\"currentColor\") === -1 ? \"bg\" : \"mask\";\n}\nconst yo = /(-?[0-9.]*[0-9]+[0-9.]*)/g, _o = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction ci(i, t, e) {\n  if (t === 1)\n    return i;\n  if (e = e || 100, typeof i == \"number\")\n    return Math.ceil(i * t * e) / e;\n  if (typeof i != \"string\")\n    return i;\n  const s = i.split(yo);\n  if (s === null || !s.length)\n    return i;\n  const n = [];\n  let r = s.shift(), o = _o.test(r);\n  for (; ; ) {\n    if (o) {\n      const a = parseFloat(r);\n      isNaN(a) ? n.push(r) : n.push(Math.ceil(a * t * e) / e);\n    } else\n      n.push(r);\n    if (r = s.shift(), r === void 0)\n      return n.join(\"\");\n    o = !o;\n  }\n}\nfunction xo(i, t = \"defs\") {\n  let e = \"\";\n  const s = i.indexOf(\"<\" + t);\n  for (; s >= 0; ) {\n    const n = i.indexOf(\">\", s), r = i.indexOf(\"</\" + t);\n    if (n === -1 || r === -1)\n      break;\n    const o = i.indexOf(\">\", r);\n    if (o === -1)\n      break;\n    e += i.slice(n + 1, r).trim(), i = i.slice(0, s).trim() + i.slice(o + 1);\n  }\n  return {\n    defs: e,\n    content: i\n  };\n}\nfunction wo(i, t) {\n  return i ? \"<defs>\" + i + \"</defs>\" + t : t;\n}\nfunction $o(i, t, e) {\n  const s = xo(i);\n  return wo(s.defs, t + s.content + e);\n}\nconst Co = (i) => i === \"unset\" || i === \"undefined\" || i === \"none\";\nfunction Ss(i, t) {\n  const e = {\n    ...ae,\n    ...i\n  }, s = {\n    ...hs,\n    ...t\n  }, n = {\n    left: e.left,\n    top: e.top,\n    width: e.width,\n    height: e.height\n  };\n  let r = e.body;\n  [e, s].forEach((v) => {\n    const g = [], A = v.hFlip, E = v.vFlip;\n    let x = v.rotate;\n    A ? E ? x += 2 : (g.push(\n      \"translate(\" + (n.width + n.left).toString() + \" \" + (0 - n.top).toString() + \")\"\n    ), g.push(\"scale(-1 1)\"), n.top = n.left = 0) : E && (g.push(\n      \"translate(\" + (0 - n.left).toString() + \" \" + (n.height + n.top).toString() + \")\"\n    ), g.push(\"scale(1 -1)\"), n.top = n.left = 0);\n    let $;\n    switch (x < 0 && (x -= Math.floor(x / 4) * 4), x = x % 4, x) {\n      case 1:\n        $ = n.height / 2 + n.top, g.unshift(\n          \"rotate(90 \" + $.toString() + \" \" + $.toString() + \")\"\n        );\n        break;\n      case 2:\n        g.unshift(\n          \"rotate(180 \" + (n.width / 2 + n.left).toString() + \" \" + (n.height / 2 + n.top).toString() + \")\"\n        );\n        break;\n      case 3:\n        $ = n.width / 2 + n.left, g.unshift(\n          \"rotate(-90 \" + $.toString() + \" \" + $.toString() + \")\"\n        );\n        break;\n    }\n    x % 2 === 1 && (n.left !== n.top && ($ = n.left, n.left = n.top, n.top = $), n.width !== n.height && ($ = n.width, n.width = n.height, n.height = $)), g.length && (r = $o(\n      r,\n      '<g transform=\"' + g.join(\" \") + '\">',\n      \"</g>\"\n    ));\n  });\n  const o = s.width, a = s.height, l = n.width, c = n.height;\n  let u, h;\n  o === null ? (h = a === null ? \"1em\" : a === \"auto\" ? c : a, u = ci(h, l / c)) : (u = o === \"auto\" ? l : o, h = a === null ? ci(u, c / l) : a === \"auto\" ? c : a);\n  const f = {}, p = (v, g) => {\n    Co(g) || (f[v] = g.toString());\n  };\n  p(\"width\", u), p(\"height\", h);\n  const b = [n.left, n.top, l, c];\n  return f.viewBox = b.join(\" \"), {\n    attributes: f,\n    viewBox: b,\n    body: r\n  };\n}\nfunction Ai(i, t) {\n  let e = i.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n  for (const s in t)\n    e += \" \" + s + '=\"' + t[s] + '\"';\n  return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + e + \">\" + i + \"</svg>\";\n}\nfunction Eo(i) {\n  return i.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction Ao(i) {\n  return \"data:image/svg+xml,\" + Eo(i);\n}\nfunction Os(i) {\n  return 'url(\"' + Ao(i) + '\")';\n}\nconst So = () => {\n  let i;\n  try {\n    if (i = fetch, typeof i == \"function\")\n      return i;\n  } catch {\n  }\n};\nlet Se = So();\nfunction Oo(i) {\n  Se = i;\n}\nfunction ko() {\n  return Se;\n}\nfunction Po(i, t) {\n  const e = He(i);\n  if (!e)\n    return 0;\n  let s;\n  if (!e.maxURL)\n    s = 0;\n  else {\n    let n = 0;\n    e.resources.forEach((o) => {\n      n = Math.max(n, o.length);\n    });\n    const r = t + \".json?icons=\";\n    s = e.maxURL - n - e.path.length - r.length;\n  }\n  return s;\n}\nfunction To(i) {\n  return i === 404;\n}\nconst Lo = (i, t, e) => {\n  const s = [], n = Po(i, t), r = \"icons\";\n  let o = {\n    type: r,\n    provider: i,\n    prefix: t,\n    icons: []\n  }, a = 0;\n  return e.forEach((l, c) => {\n    a += l.length + 1, a >= n && c > 0 && (s.push(o), o = {\n      type: r,\n      provider: i,\n      prefix: t,\n      icons: []\n    }, a = l.length), o.icons.push(l);\n  }), s.push(o), s;\n};\nfunction Io(i) {\n  if (typeof i == \"string\") {\n    const t = He(i);\n    if (t)\n      return t.path;\n  }\n  return \"/\";\n}\nconst zo = (i, t, e) => {\n  if (!Se) {\n    e(\"abort\", 424);\n    return;\n  }\n  let s = Io(t.provider);\n  switch (t.type) {\n    case \"icons\": {\n      const r = t.prefix, a = t.icons.join(\",\"), l = new URLSearchParams({\n        icons: a\n      });\n      s += r + \".json?\" + l.toString();\n      break;\n    }\n    case \"custom\": {\n      const r = t.uri;\n      s += r.slice(0, 1) === \"/\" ? r.slice(1) : r;\n      break;\n    }\n    default:\n      e(\"abort\", 400);\n      return;\n  }\n  let n = 503;\n  Se(i + s).then((r) => {\n    const o = r.status;\n    if (o !== 200) {\n      setTimeout(() => {\n        e(To(o) ? \"abort\" : \"next\", o);\n      });\n      return;\n    }\n    return n = 501, r.json();\n  }).then((r) => {\n    if (typeof r != \"object\" || r === null) {\n      setTimeout(() => {\n        r === 404 ? e(\"abort\", r) : e(\"next\", n);\n      });\n      return;\n    }\n    setTimeout(() => {\n      e(\"success\", r);\n    });\n  }).catch(() => {\n    e(\"next\", n);\n  });\n}, Ro = {\n  prepare: Lo,\n  send: zo\n};\nfunction En(i, t) {\n  switch (i) {\n    case \"local\":\n    case \"session\":\n      wt[i] = t;\n      break;\n    case \"all\":\n      for (const e in wt)\n        wt[e] = t;\n      break;\n  }\n}\nconst ti = \"data-style\";\nlet ks = \"\";\nfunction Mo(i) {\n  ks = i;\n}\nfunction An(i, t) {\n  let e = Array.from(i.childNodes).find((s) => s.hasAttribute && s.hasAttribute(ti));\n  e || (e = document.createElement(\"style\"), e.setAttribute(ti, ti), i.appendChild(e)), e.textContent = \":host{display:inline-block;vertical-align:\" + (t ? \"-0.125em\" : \"0\") + \"}span,svg{display:block}\" + ks;\n}\nfunction Ps() {\n  vn(\"\", Ro), ms(!0);\n  let i;\n  try {\n    i = window;\n  } catch {\n  }\n  if (i) {\n    if (Es(), i.IconifyPreload !== void 0) {\n      const e = i.IconifyPreload, s = \"Invalid IconifyPreload syntax.\";\n      typeof e == \"object\" && e !== null && (e instanceof Array ? e : [e]).forEach((n) => {\n        try {\n          // Check if item is an object and not null/array\n          (typeof n != \"object\" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'\n          typeof n.icons != \"object\" || typeof n.prefix != \"string\" || // Add icon set\n          !bn(n)) && console.error(s);\n        } catch {\n          console.error(s);\n        }\n      });\n    }\n    if (i.IconifyProviders !== void 0) {\n      const e = i.IconifyProviders;\n      if (typeof e == \"object\" && e !== null)\n        for (const s in e) {\n          const n = \"IconifyProviders[\" + s + \"] is invalid.\";\n          try {\n            const r = e[s];\n            if (typeof r != \"object\" || !r || r.resources === void 0)\n              continue;\n            yn(s, r) || console.error(n);\n          } catch {\n            console.error(n);\n          }\n        }\n    }\n  }\n  return {\n    enableCache: (e) => En(e, !0),\n    disableCache: (e) => En(e, !1),\n    iconLoaded: gn,\n    iconExists: gn,\n    getIcon: Jr,\n    listIcons: Xr,\n    addIcon: bs,\n    addCollection: bn,\n    calculateSize: ci,\n    buildIcon: Ss,\n    iconToHTML: Ai,\n    svgToURL: Os,\n    loadIcons: Ei,\n    loadIcon: mo,\n    addAPIProvider: yn,\n    appendCustomStyle: Mo,\n    _api: {\n      getAPIConfig: He,\n      setAPIModule: vn,\n      sendAPIQuery: ys,\n      setFetch: Oo,\n      getFetch: ko,\n      listAPIProviders: ro\n    }\n  };\n}\nconst ui = {\n  \"background-color\": \"currentColor\"\n}, Ts = {\n  \"background-color\": \"transparent\"\n}, Sn = {\n  image: \"var(--svg)\",\n  repeat: \"no-repeat\",\n  size: \"100% 100%\"\n}, On = {\n  \"-webkit-mask\": ui,\n  mask: ui,\n  background: Ts\n};\nfor (const i in On) {\n  const t = On[i];\n  for (const e in Sn)\n    t[i + \"-\" + e] = Sn[e];\n}\nfunction kn(i) {\n  return i ? i + (i.match(/^[-0-9.]+$/) ? \"px\" : \"\") : \"inherit\";\n}\nfunction jo(i, t, e) {\n  const s = document.createElement(\"span\");\n  let n = i.body;\n  n.indexOf(\"<a\") !== -1 && (n += \"<!-- \" + Date.now() + \" -->\");\n  const r = i.attributes, o = Ai(n, {\n    ...r,\n    width: t.width + \"\",\n    height: t.height + \"\"\n  }), a = Os(o), l = s.style, c = {\n    \"--svg\": a,\n    width: kn(r.width),\n    height: kn(r.height),\n    ...e ? ui : Ts\n  };\n  for (const u in c)\n    l.setProperty(u, c[u]);\n  return s;\n}\nlet Yt;\nfunction Bo() {\n  try {\n    Yt = window.trustedTypes.createPolicy(\"iconify\", {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      createHTML: (i) => i\n    });\n  } catch {\n    Yt = null;\n  }\n}\nfunction No(i) {\n  return Yt === void 0 && Bo(), Yt ? Yt.createHTML(i) : i;\n}\nfunction Ho(i) {\n  const t = document.createElement(\"span\"), e = i.attributes;\n  let s = \"\";\n  e.width || (s = \"width: inherit;\"), e.height || (s += \"height: inherit;\"), s && (e.style = s);\n  const n = Ai(i.body, e);\n  return t.innerHTML = No(n), t.firstChild;\n}\nfunction hi(i) {\n  return Array.from(i.childNodes).find((t) => {\n    const e = t.tagName && t.tagName.toUpperCase();\n    return e === \"SPAN\" || e === \"SVG\";\n  });\n}\nfunction Pn(i, t) {\n  const e = t.icon.data, s = t.customisations, n = Ss(e, s);\n  s.preserveAspectRatio && (n.attributes.preserveAspectRatio = s.preserveAspectRatio);\n  const r = t.renderedMode;\n  let o;\n  switch (r) {\n    case \"svg\":\n      o = Ho(n);\n      break;\n    default:\n      o = jo(n, {\n        ...ae,\n        ...e\n      }, r === \"mask\");\n  }\n  const a = hi(i);\n  a ? o.tagName === \"SPAN\" && a.tagName === o.tagName ? a.setAttribute(\"style\", o.getAttribute(\"style\")) : i.replaceChild(o, a) : i.appendChild(o);\n}\nfunction Tn(i, t, e) {\n  const s = e && (e.rendered ? e : e.lastRender);\n  return {\n    rendered: !1,\n    inline: t,\n    icon: i,\n    lastRender: s\n  };\n}\nfunction Do(i = \"iconify-icon\") {\n  let t, e;\n  try {\n    t = window.customElements, e = window.HTMLElement;\n  } catch {\n    return;\n  }\n  if (!t || !e)\n    return;\n  const s = t.get(i);\n  if (s)\n    return s;\n  const n = [\n    // Icon\n    \"icon\",\n    // Mode\n    \"mode\",\n    \"inline\",\n    \"observe\",\n    // Customisations\n    \"width\",\n    \"height\",\n    \"rotate\",\n    \"flip\"\n  ], r = class extends e {\n    /**\n     * Constructor\n     */\n    constructor() {\n      super();\n      // Root\n      tt(this, \"_shadowRoot\");\n      // Initialised\n      tt(this, \"_initialised\", !1);\n      // Icon state\n      tt(this, \"_state\");\n      // Attributes check queued\n      tt(this, \"_checkQueued\", !1);\n      // Connected\n      tt(this, \"_connected\", !1);\n      // Observer\n      tt(this, \"_observer\", null);\n      tt(this, \"_visible\", !0);\n      const l = this._shadowRoot = this.attachShadow({\n        mode: \"open\"\n      }), c = Ze(this);\n      An(l, c), this._state = Tn({\n        value: \"\"\n      }, c), this._queueCheck();\n    }\n    /**\n     * Connected to DOM\n     */\n    connectedCallback() {\n      this._connected = !0, this.startObserver();\n    }\n    /**\n     * Disconnected from DOM\n     */\n    disconnectedCallback() {\n      this._connected = !1, this.stopObserver();\n    }\n    /**\n     * Observed attributes\n     */\n    static get observedAttributes() {\n      return n.slice(0);\n    }\n    /**\n     * Observed properties that are different from attributes\n     *\n     * Experimental! Need to test with various frameworks that support it\n     */\n    /*\n    static get properties() {\n        return {\n            inline: {\n                type: Boolean,\n                reflect: true,\n            },\n            // Not listing other attributes because they are strings or combination\n            // of string and another type. Cannot have multiple types\n        };\n    }\n    */\n    /**\n     * Attribute has changed\n     */\n    attributeChangedCallback(l) {\n      switch (l) {\n        case \"inline\": {\n          const c = Ze(this), u = this._state;\n          c !== u.inline && (u.inline = c, An(this._shadowRoot, c));\n          break;\n        }\n        case \"observer\": {\n          this.observer ? this.startObserver() : this.stopObserver();\n          break;\n        }\n        default:\n          this._queueCheck();\n      }\n    }\n    /**\n     * Get/set icon\n     */\n    get icon() {\n      const l = this.getAttribute(\"icon\");\n      if (l && l.slice(0, 1) === \"{\")\n        try {\n          return JSON.parse(l);\n        } catch {\n        }\n      return l;\n    }\n    set icon(l) {\n      typeof l == \"object\" && (l = JSON.stringify(l)), this.setAttribute(\"icon\", l);\n    }\n    /**\n     * Get/set inline\n     */\n    get inline() {\n      return Ze(this);\n    }\n    set inline(l) {\n      l ? this.setAttribute(\"inline\", \"true\") : this.removeAttribute(\"inline\");\n    }\n    /**\n     * Get/set observer\n     */\n    get observer() {\n      return this.hasAttribute(\"observer\");\n    }\n    set observer(l) {\n      l ? this.setAttribute(\"observer\", \"true\") : this.removeAttribute(\"observer\");\n    }\n    /**\n     * Restart animation\n     */\n    restartAnimation() {\n      const l = this._state;\n      if (l.rendered) {\n        const c = this._shadowRoot;\n        if (l.renderedMode === \"svg\")\n          try {\n            c.lastChild.setCurrentTime(0);\n            return;\n          } catch {\n          }\n        Pn(c, l);\n      }\n    }\n    /**\n     * Get status\n     */\n    get status() {\n      const l = this._state;\n      return l.rendered ? \"rendered\" : l.icon.data === null ? \"failed\" : \"loading\";\n    }\n    /**\n     * Queue attributes re-check\n     */\n    _queueCheck() {\n      this._checkQueued || (this._checkQueued = !0, setTimeout(() => {\n        this._check();\n      }));\n    }\n    /**\n     * Check for changes\n     */\n    _check() {\n      if (!this._checkQueued)\n        return;\n      this._checkQueued = !1;\n      const l = this._state, c = this.getAttribute(\"icon\");\n      if (c !== l.icon.value) {\n        this._iconChanged(c);\n        return;\n      }\n      if (!l.rendered || !this._visible)\n        return;\n      const u = this.getAttribute(\"mode\"), h = pn(this);\n      (l.attrMode !== u || Vr(l.customisations, h) || !hi(this._shadowRoot)) && this._renderIcon(l.icon, h, u);\n    }\n    /**\n     * Icon value has changed\n     */\n    _iconChanged(l) {\n      const c = go(l, (u, h, f) => {\n        const p = this._state;\n        if (p.rendered || this.getAttribute(\"icon\") !== u)\n          return;\n        const b = {\n          value: u,\n          name: h,\n          data: f\n        };\n        b.data ? this._gotIconData(b) : p.icon = b;\n      });\n      c.data ? this._gotIconData(c) : this._state = Tn(c, this._state.inline, this._state);\n    }\n    /**\n     * Force render icon on state change\n     */\n    _forceRender() {\n      if (!this._visible) {\n        const l = hi(this._shadowRoot);\n        l && this._shadowRoot.removeChild(l);\n        return;\n      }\n      this._queueCheck();\n    }\n    /**\n     * Got new icon data, icon is ready to (re)render\n     */\n    _gotIconData(l) {\n      this._checkQueued = !1, this._renderIcon(l, pn(this), this.getAttribute(\"mode\"));\n    }\n    /**\n     * Re-render based on icon data\n     */\n    _renderIcon(l, c, u) {\n      const h = vo(l.data.body, u), f = this._state.inline;\n      Pn(this._shadowRoot, this._state = {\n        rendered: !0,\n        icon: l,\n        inline: f,\n        customisations: c,\n        attrMode: u,\n        renderedMode: h\n      });\n    }\n    /**\n     * Start observer\n     */\n    startObserver() {\n      if (!this._observer)\n        try {\n          this._observer = new IntersectionObserver((l) => {\n            const c = l.some((u) => u.isIntersecting);\n            c !== this._visible && (this._visible = c, this._forceRender());\n          }), this._observer.observe(this);\n        } catch {\n          if (this._observer) {\n            try {\n              this._observer.disconnect();\n            } catch {\n            }\n            this._observer = null;\n          }\n        }\n    }\n    /**\n     * Stop observer\n     */\n    stopObserver() {\n      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = !0, this._connected && this._forceRender());\n    }\n  };\n  n.forEach((a) => {\n    a in r.prototype || Object.defineProperty(r.prototype, a, {\n      get: function() {\n        return this.getAttribute(a);\n      },\n      set: function(l) {\n        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);\n      }\n    });\n  });\n  const o = Ps();\n  for (const a in o)\n    r[a] = r.prototype[a] = o[a];\n  return t.define(i, r), r;\n}\nDo() || Ps();\nvar Fo = Object.defineProperty, U = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && Fo(t, e, n), n;\n}, Bt;\nconst H = (Bt = class extends w {\n  constructor() {\n    super(), this.labelHidden = !1, this.active = !1, this.disabled = !1, this.vertical = !1, this.tooltipVisible = !1, this._parent = nt(), this._tooltip = nt(), this._contextMenu = nt(), this._mouseLeave = !1, this.onWindowMouseUp = (t) => {\n      const { value: e } = this._contextMenu;\n      !this.contains(t.target) && e && (e.visible = !1);\n    }, this.mouseLeave = !0, this.addEventListener(\"click\", (t) => t.stopPropagation());\n  }\n  set mouseLeave(t) {\n    this._mouseLeave = t, t && (this.tooltipVisible = !1, clearTimeout(this.timeoutID));\n  }\n  get mouseLeave() {\n    return this._mouseLeave;\n  }\n  computeTooltipPosition() {\n    const { value: t } = this._parent, { value: e } = this._tooltip;\n    t && e && Zn(t, e, {\n      placement: \"bottom\",\n      middleware: [Hn(10), Kn(), Jn(), Xn({ padding: 5 })]\n    }).then((s) => {\n      const { x: n, y: r } = s;\n      Object.assign(e.style, {\n        left: `${n}px`,\n        top: `${r}px`\n      });\n    });\n  }\n  onMouseEnter() {\n    if (!(this.tooltipTitle || this.tooltipText))\n      return;\n    this.mouseLeave = !1;\n    const t = this.tooltipTime ?? 700;\n    this.timeoutID = setTimeout(() => {\n      this.mouseLeave || (this.computeTooltipPosition(), this.tooltipVisible = !0);\n    }, t);\n  }\n  onChildrenClick(t) {\n    t.stopPropagation();\n    const { value: e } = this._contextMenu;\n    e && (e.visible = !e.visible);\n  }\n  onSlotChange(t) {\n    const { value: e } = this._contextMenu, s = t.target.assignedElements();\n    for (const n of s) {\n      if (!(n instanceof Bt)) {\n        n.remove(), console.warn(\n          \"Only bim-button is allowed inside bim-button. Child has been removed.\"\n        );\n        continue;\n      }\n      n.addEventListener(\"click\", () => e == null ? void 0 : e.updatePosition());\n    }\n    this.requestUpdate();\n  }\n  connectedCallback() {\n    super.connectedCallback(), window.addEventListener(\"mouseup\", this.onWindowMouseUp);\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback(), window.removeEventListener(\"mouseup\", this.onWindowMouseUp);\n  }\n  render() {\n    const t = m`\n      <div ${st(this._tooltip)} class=\"tooltip\">\n        ${this.tooltipTitle ? m`<p style=\"text-wrap: nowrap;\">\n              <strong>${this.tooltipTitle}</strong>\n            </p>` : null}\n        ${this.tooltipText ? m`<p style=\"width: 9rem;\">${this.tooltipText}</p>` : null}\n      </div>\n    `, e = this.children.length > 0;\n    return m`\n      <style>\n        .button {\n          border-radius: var(\n            --bim-button--bdrs,\n            ${e ? \"var(--bim-ui_size-4xs) 0 0 var(--bim-ui_size-4xs)\" : \"var(--bim-ui_size-4xs)\"}\n          );\n        }\n        .children {\n          border-radius: var(\n            --bim-button--bdrs,\n            ${e ? \"0 var(--bim-ui_size-4xs) var(--bim-ui_size-4xs) 0\" : \"var(--bim-ui_size-4xs)\"}\n          );\n        }\n      </style>\n      <div ${st(this._parent)} class=\"parent\">\n        ${this.label || this.icon ? m`\n              <div\n                class=\"button\"\n                @mouseenter=${this.onMouseEnter}\n                @mouseleave=${() => this.mouseLeave = !0}\n              >\n                <bim-label\n                  .icon=${this.icon}\n                  .vertical=${this.vertical}\n                  .labelHidden=${this.labelHidden}\n                  >${this.label}</bim-label\n                >\n              </div>\n            ` : null}\n        ${this.tooltipTitle || this.tooltipText ? t : null}\n        ${e ? m`\n              <div class=\"children\" @click=${this.onChildrenClick}>\n                <bim-icon .icon=${\"ic:round-plus\"}></bim-icon>\n              </div>\n            ` : null}\n        <bim-context-menu\n          ${st(this._contextMenu)}\n          style=\"row-gap: var(--bim-ui_size-4xs)\"\n        >\n          <slot @slotchange=${this.onSlotChange}></slot>\n        </bim-context-menu>\n      </div>\n    `;\n  }\n}, Bt.styles = C`\n    :host {\n      --bim-label--c: var(--bim-ui_bg-contrast-100);\n      display: block;\n      flex: 1;\n      pointer-events: none;\n    }\n\n    :host(:not([disabled]):hover) {\n      cursor: pointer;\n    }\n\n    bim-label {\n      pointer-events: none;\n    }\n\n    .parent {\n      --bim-label--fz: var(--bim-ui_size-xs);\n      --bim-icon--c: var(--bim-label--c);\n      display: flex;\n      height: 100%;\n      user-select: none;\n      row-gap: 0.125rem;\n      column-gap: 0.125rem;\n    }\n\n    .button,\n    .children {\n      box-sizing: border-box;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      pointer-events: auto;\n      min-height: var(--bim-ui_size-5xl);\n      min-width: var(--bim-ui_size-5xl);\n      background-color: var(--bim-button--bgc, var(--bim-ui_bg-contrast-20));\n      outline: var(--bim-button--olw) solid var(--bim-button--olc);\n    }\n\n    .button {\n      flex-grow: 1;\n    }\n\n    :host(:not([label-hidden])[label]) .button {\n      justify-content: var(--bim-button--jc, center);\n    }\n\n    :host(:hover) .button,\n    :host(:hover) .children {\n      --bim-label--c: var(--bim-ui_main-contrast);\n      --bim-icon--c: var(--bim-ui_main-contrast);\n      fill: white;\n      background-color: var(--bim-ui_main-base);\n    }\n\n    :host(:not([label]):not([icon])) .children {\n      flex: 1;\n    }\n\n    :host([active]) .button {\n      --bim-label--c: var(--bim-ui_main-contrast);\n      --bim-icon--c: var(--bim-ui_main-contrast);\n      background-color: var(--bim-ui_main-base);\n    }\n\n    :host([vertical]) .parent {\n      justify-content: center;\n    }\n\n    :host(:not([label-hidden])[label]) .button {\n      padding: 0 0.5rem;\n    }\n\n    :host([disabled]) .parent {\n      background-color: gray;\n    }\n\n    .children {\n      --bim-icon--fz: var(--bim-ui_size-base);\n      padding: 0 0.125rem;\n    }\n\n    ::slotted(bim-button) {\n      --bim-icon--fz: var(--bim-ui_size-base);\n      --bim-button--bgc: var(\n        --bim-context-menu--bgc,\n        var(--bim-ui_bg-contrast-20)\n      );\n      --bim-button--bdrs: var(--bim-ui_size-4xs);\n      --bim-button--olw: 0;\n      --bim-button--olc: transparent;\n    }\n\n    .tooltip {\n      position: absolute;\n      padding: 0.75rem;\n      z-index: 99;\n      display: flex;\n      flex-flow: column;\n      row-gap: 0.375rem;\n      box-shadow: 0 0 10px 3px rgba(0 0 0 / 20%);\n      outline: 1px solid var(--bim-ui_bg-contrast-40);\n      font-size: var(--bim-ui_size-xs);\n      border-radius: var(--bim-ui_size-4xs);\n      background-color: var(--bim-ui_bg-contrast-20);\n      color: var(--bim-ui_bg-contrast-100);\n    }\n\n    .tooltip p {\n      margin: 0;\n      padding: 0;\n    }\n\n    :host(:not([tooltip-visible])) .tooltip {\n      display: none;\n    }\n  `, Bt);\nU([\n  d({ type: String, reflect: !0 })\n], H.prototype, \"label\");\nU([\n  d({ type: Boolean, attribute: \"label-hidden\", reflect: !0 })\n], H.prototype, \"labelHidden\");\nU([\n  d({ type: Boolean, reflect: !0 })\n], H.prototype, \"active\");\nU([\n  d({ type: Boolean, reflect: !0, attribute: \"disabled\" })\n], H.prototype, \"disabled\");\nU([\n  d({ type: String, reflect: !0 })\n], H.prototype, \"icon\");\nU([\n  d({ type: Boolean, reflect: !0 })\n], H.prototype, \"vertical\");\nU([\n  d({ type: Number, attribute: \"tooltip-time\", reflect: !0 })\n], H.prototype, \"tooltipTime\");\nU([\n  d({ type: Boolean, attribute: \"tooltip-visible\", reflect: !0 })\n], H.prototype, \"tooltipVisible\");\nU([\n  d({ type: String, attribute: \"tooltip-title\", reflect: !0 })\n], H.prototype, \"tooltipTitle\");\nU([\n  d({ type: String, attribute: \"tooltip-text\", reflect: !0 })\n], H.prototype, \"tooltipText\");\nlet Vo = H;\nvar Uo = Object.defineProperty, ue = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && Uo(t, e, n), n;\n};\nconst Oi = class Oi extends w {\n  constructor() {\n    super(...arguments), this.checked = !1, this.inverted = !1, this.onValueChange = new Event(\"change\");\n  }\n  /**\n   * A getter that returns the current checked state of the checkbox. This is useful for retrieving the checkbox's value in form submissions or JavaScript interactions as it provides a consistent `value` property as many other components.\n   * @type {boolean}\n   * @default false\n   * @example <script>console.log(document.querySelector('bim-checkbox').value);<\\/script>\n   * @example\n   * const checkbox = document.createElement('bim-checkbox');\n   * document.body.appendChild(checkbox);\n   * console.log(checkbox.value); // false initially\n   */\n  get value() {\n    return this.checked;\n  }\n  onChange(t) {\n    t.stopPropagation(), this.checked = t.target.checked, this.dispatchEvent(this.onValueChange);\n  }\n  render() {\n    return m`\n      <div class=\"parent\">\n        ${this.label ? m`<bim-label .icon=\"${this.icon}\">${this.label}</bim-label> ` : null}\n        <input\n          type=\"checkbox\"\n          aria-label=${this.label || this.name || \"Checkbox Input\"}\n          @change=\"${this.onChange}\"\n          .checked=\"${this.checked}\"\n        />\n      </div>\n    `;\n  }\n};\nOi.styles = C`\n    :host {\n      display: block;\n    }\n\n    .parent {\n      display: flex;\n      justify-content: space-between;\n      height: 1.75rem;\n      column-gap: 0.5rem;\n      width: 100%;\n      align-items: center;\n    }\n\n    :host([inverted]) .parent {\n      flex-direction: row-reverse;\n      justify-content: start;\n    }\n\n    input {\n      height: 1rem;\n      width: 1rem;\n      cursor: pointer;\n      border: none;\n      outline: none;\n      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));\n    }\n\n    input:focus {\n      outline: var(--bim-checkbox--olw, 2px) solid\n        var(--bim-checkbox--olc, var(--bim-ui_accent-base));\n    }\n  `;\nlet at = Oi;\nue([\n  d({ type: String, reflect: !0 })\n], at.prototype, \"icon\");\nue([\n  d({ type: String, reflect: !0 })\n], at.prototype, \"name\");\nue([\n  d({ type: String, reflect: !0 })\n], at.prototype, \"label\");\nue([\n  d({ type: Boolean, reflect: !0 })\n], at.prototype, \"checked\");\nue([\n  d({ type: Boolean, reflect: !0 })\n], at.prototype, \"inverted\");\nvar qo = Object.defineProperty, Nt = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && qo(t, e, n), n;\n};\nconst ki = class ki extends w {\n  constructor() {\n    super(...arguments), this.vertical = !1, this.color = \"#bcf124\", this._colorInput = nt(), this._textInput = nt(), this.onValueChange = new Event(\"input\"), this.onOpacityInput = (t) => {\n      const e = t.target;\n      this.opacity = e.value, this.dispatchEvent(this.onValueChange);\n    };\n  }\n  /**\n   * Represents both the color and opacity values combined into a single object. This is an instance property, not an HTMLElement attribute.\n   * @type {Object}\n   * @example\n   * const colorInput = document.createElement('bim-color-input');\n   * colorInput.value = { color: '#ff0000', opacity: 0.5 };\n   */\n  set value(t) {\n    const { color: e, opacity: s } = t;\n    this.color = e, s && (this.opacity = s);\n  }\n  get value() {\n    const t = {\n      color: this.color\n    };\n    return this.opacity && (t.opacity = this.opacity), t;\n  }\n  onColorInput(t) {\n    t.stopPropagation();\n    const { value: e } = this._colorInput;\n    e && (this.color = e.value, this.dispatchEvent(this.onValueChange));\n  }\n  onTextInput(t) {\n    t.stopPropagation();\n    const { value: e } = this._textInput;\n    if (!e)\n      return;\n    const { value: s } = e;\n    let n = s.replace(/[^a-fA-F0-9]/g, \"\");\n    n.startsWith(\"#\") || (n = `#${n}`), e.value = n.slice(0, 7), e.value.length === 7 && (this.color = e.value, this.dispatchEvent(this.onValueChange));\n  }\n  /**\n   * Focuses on the color input by programmatically triggering a click event on the underlying color input element.\n   * If the color input element is not available, the function does nothing.\n   */\n  focus() {\n    const { value: t } = this._colorInput;\n    t && t.click();\n  }\n  render() {\n    return m`\n      <div class=\"parent\">\n        <bim-input\n          .label=${this.label}\n          .icon=${this.icon}\n          .vertical=\"${this.vertical}\"\n        >\n          <div class=\"color-container\">\n            <div\n              style=\"display: flex; align-items: center; gap: .375rem; height: 100%; flex: 1; padding: 0 0.5rem;\"\n            >\n              <input\n                ${st(this._colorInput)}\n                @input=\"${this.onColorInput}\"\n                type=\"color\"\n                aria-label=${this.label || this.name || \"Color Input\"}\n                value=\"${this.color}\"\n              />\n              <div\n                @click=${this.focus}\n                class=\"sample\"\n                style=\"background-color: ${this.color}\"\n              ></div>\n              <input\n                ${st(this._textInput)}\n                @input=\"${this.onTextInput}\"\n                value=\"${this.color}\"\n                type=\"text\"\n                aria-label=${this.label || this.name || \"Text Color Input\"}\n              />\n            </div>\n            ${this.opacity !== void 0 ? m`<bim-number-input\n                  @change=${this.onOpacityInput}\n                  slider\n                  suffix=\"%\"\n                  min=\"0\"\n                  value=${this.opacity}\n                  max=\"100\"\n                ></bim-number-input>` : null}\n          </div>\n        </bim-input>\n      </div>\n    `;\n  }\n};\nki.styles = C`\n    :host {\n      --bim-input--bgc: var(--bim-ui_bg-contrast-20);\n      flex: 1;\n      display: block;\n    }\n\n    :host(:focus) {\n      --bim-input--olw: var(--bim-number-input--olw, 2px);\n      --bim-input--olc: var(--bim-ui_accent-base);\n    }\n\n    .parent {\n      display: flex;\n      gap: 0.375rem;\n    }\n\n    .color-container {\n      position: relative;\n      outline: none;\n      display: flex;\n      height: 100%;\n      gap: 0.5rem;\n      justify-content: flex-start;\n      align-items: center;\n      flex: 1;\n      border-radius: var(--bim-color-input--bdrs, var(--bim-ui_size-4xs));\n    }\n\n    .color-container input[type=\"color\"] {\n      position: absolute;\n      bottom: -0.25rem;\n      visibility: hidden;\n      width: 0;\n      height: 0;\n    }\n\n    .color-container .sample {\n      width: 1rem;\n      height: 1rem;\n      border-radius: 0.125rem;\n      background-color: #fff;\n    }\n\n    .color-container input[type=\"text\"] {\n      height: 100%;\n      flex: 1;\n      width: 3.25rem;\n      text-transform: uppercase;\n      font-size: 0.75rem;\n      background-color: transparent;\n      padding: 0%;\n      outline: none;\n      border: none;\n      color: var(--bim-color-input--c, var(--bim-ui_bg-contrast-100));\n    }\n\n    bim-number-input {\n      flex-grow: 0;\n    }\n  `;\nlet X = ki;\nNt([\n  d({ type: String, reflect: !0 })\n], X.prototype, \"name\");\nNt([\n  d({ type: String, reflect: !0 })\n], X.prototype, \"label\");\nNt([\n  d({ type: String, reflect: !0 })\n], X.prototype, \"icon\");\nNt([\n  d({ type: Boolean, reflect: !0 })\n], X.prototype, \"vertical\");\nNt([\n  d({ type: Number, reflect: !0 })\n], X.prototype, \"opacity\");\nNt([\n  d({ type: String, reflect: !0 })\n], X.prototype, \"color\");\nconst Wo = C`\n  ::-webkit-scrollbar {\n    width: 0.4rem;\n    height: 0.4rem;\n    overflow: hidden;\n  }\n\n  ::-webkit-scrollbar-thumb {\n    border-radius: 0.25rem;\n    background-color: var(\n      --bim-scrollbar--c,\n      color-mix(in lab, var(--bim-ui_main-base), white 15%)\n    );\n  }\n\n  ::-webkit-scrollbar-track {\n    background-color: var(--bim-scrollbar--bgc, var(--bim-ui_bg-base));\n  }\n`, Qo = C`\n  :root {\n    /* Grayscale Colors */\n    --bim-ui_gray-0: hsl(210 10% 5%);\n    --bim-ui_gray-1: hsl(210 10% 10%);\n    --bim-ui_gray-2: hsl(210 10% 20%);\n    --bim-ui_gray-4: hsl(210 10% 40%);\n    --bim-ui_gray-6: hsl(210 10% 60%);\n    --bim-ui_gray-8: hsl(210 10% 80%);\n    --bim-ui_gray-9: hsl(210 10% 90%);\n    --bim-ui_gray-10: hsl(210 10% 95%);\n\n    /* Brand Colors */\n    --bim-ui_main-base: #6528d7;\n    --bim-ui_accent-base: #bcf124;\n\n    /* Brand Colors Contrasts */\n    --bim-ui_main-contrast: var(--bim-ui_gray-10);\n    --bim-ui_accent-contrast: var(--bim-ui_gray-0);\n\n    /* Sizes */\n    --bim-ui_size-4xs: 0.375rem;\n    --bim-ui_size-3xs: 0.5rem;\n    --bim-ui_size-2xs: 0.625rem;\n    --bim-ui_size-xs: 0.75rem;\n    --bim-ui_size-sm: 0.875rem;\n    --bim-ui_size-base: 1rem;\n    --bim-ui_size-lg: 1.125rem;\n    --bim-ui_size-xl: 1.25rem;\n    --bim-ui_size-2xl: 1.375rem;\n    --bim-ui_size-3xl: 1.5rem;\n    --bim-ui_size-4xl: 1.625rem;\n    --bim-ui_size-5xl: 1.75rem;\n    --bim-ui_size-6xl: 1.875rem;\n    --bim-ui_size-7xl: 2rem;\n    --bim-ui_size-8xl: 2.125rem;\n    --bim-ui_size-9xl: 2.25rem;\n  }\n\n  /* Background Colors */\n  @media (prefers-color-scheme: dark) {\n    :root {\n      --bim-ui_bg-base: var(--bim-ui_gray-0);\n      --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);\n      --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);\n      --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);\n      --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);\n      --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);\n      --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);\n    }\n  }\n\n  @media (prefers-color-scheme: light) {\n    :root {\n      --bim-ui_bg-base: var(--bim-ui_gray-10);\n      --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);\n      --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);\n      --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);\n      --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);\n      --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);\n      --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);\n      --bim-ui_accent-base: #6528d7;\n    }\n  }\n\n  html.bim-ui-dark {\n    --bim-ui_bg-base: var(--bim-ui_gray-0);\n    --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);\n    --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);\n    --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);\n    --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);\n    --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);\n    --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);\n  }\n\n  html.bim-ui-light {\n    --bim-ui_bg-base: var(--bim-ui_gray-10);\n    --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);\n    --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);\n    --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);\n    --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);\n    --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);\n    --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);\n    --bim-ui_accent-base: #6528d7;\n  }\n`, At = {\n  scrollbar: Wo,\n  globalStyles: Qo\n};\nvar Yo = Object.defineProperty, Go = Object.getOwnPropertyDescriptor, Xo = (i, t, e, s) => {\n  for (var n = Go(t, e), r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && Yo(t, e, n), n;\n};\nconst Pi = class Pi extends w {\n  constructor() {\n    super(...arguments), this._visible = !1, this._middleware = {\n      name: \"middleware\",\n      async fn(t) {\n        const { right: e, top: s } = await mi(t);\n        return t.x -= Math.sign(e) === 1 ? e + 5 : 0, t.y -= Math.sign(s) === 1 ? s + 5 : 0, t;\n      }\n    };\n  }\n  get visible() {\n    return this._visible;\n  }\n  set visible(t) {\n    this._visible = t, t && this.updatePosition();\n  }\n  /**\n   * Asynchronously updates the position of the context menu relative to a target element.\n   * If no target element is provided, it attempts to use the parent node as the target.\n   * The position is calculated using the `computePosition` function from `@floating-ui/dom`,\n   * which considers various adjustments like offset, inline positioning, flipping, and shifting\n   * to ensure the context menu is properly placed relative to the target element.\n   *\n   * @param [target] - The target element relative to which the context menu should be positioned.\n   *                                 If not provided, the parent node is used as the target.\n   * @returns A promise that resolves once the position has been updated. This method\n   *                          does not explicitly return a value but updates the context menu's style\n   *                          properties to position it on the screen.\n   */\n  async updatePosition(t) {\n    const e = t || this.parentNode;\n    if (!e) {\n      this.visible = !1, console.warn(\"No target element found for context-menu.\");\n      return;\n    }\n    const s = await Zn(e, this, {\n      placement: \"right\",\n      middleware: [\n        Hn(10),\n        Kn(),\n        Jn(),\n        Xn({ padding: 5 }),\n        this._middleware\n      ]\n    }), { x: n, y: r } = s;\n    this.style.left = `${n}px`, this.style.top = `${r}px`;\n  }\n  render() {\n    return m` <slot></slot> `;\n  }\n};\nPi.styles = [\n  At.scrollbar,\n  C`\n      :host {\n        --bim-label--fz: var(--bim-ui_size-xs);\n        position: absolute;\n        top: 0;\n        left: 0;\n        z-index: 999;\n        overflow: auto;\n        max-height: 20rem;\n        min-width: 3rem;\n        flex-direction: column;\n        box-shadow: 1px 2px 8px 2px rgba(0, 0, 0, 0.15);\n        padding: 0.5rem;\n        border-radius: var(--bim-ui_size-4xs);\n        background-color: var(\n          --bim-context-menu--bgc,\n          var(--bim-ui_bg-contrast-20)\n        );\n      }\n\n      :host([visible]) {\n        display: flex;\n      }\n\n      :host(:not([visible])) {\n        display: none;\n      }\n    `\n];\nlet Oe = Pi;\nXo([\n  d({ type: Boolean, reflect: !0 })\n], Oe.prototype, \"visible\");\nclass Jo extends w {\n  constructor() {\n    super(...arguments), this._lazyLoadObserver = null, this._visibleElements = [], this.ELEMENTS_BEFORE_OBSERVER = 20, this.useObserver = !1, this.elements = /* @__PURE__ */ new Set(), this.observe = (t) => {\n      if (!this.useObserver)\n        return;\n      for (const s of t)\n        this.elements.add(s);\n      const e = t.slice(this.ELEMENTS_BEFORE_OBSERVER);\n      for (const s of e)\n        s.remove();\n      this.observeLastElement();\n    };\n  }\n  set visibleElements(t) {\n    this._visibleElements = this.useObserver ? t : [], this.requestUpdate();\n  }\n  get visibleElements() {\n    return this._visibleElements;\n  }\n  getLazyObserver() {\n    if (!this.useObserver)\n      return null;\n    if (this._lazyLoadObserver)\n      return this._lazyLoadObserver;\n    const t = new IntersectionObserver(\n      (e) => {\n        const s = e[0];\n        if (!s.isIntersecting)\n          return;\n        const n = s.target;\n        t.unobserve(n);\n        const r = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length, o = [...this.elements][r];\n        o && (this.visibleElements = [...this.visibleElements, o], t.observe(o));\n      },\n      { threshold: 0.5 }\n    );\n    return t;\n  }\n  observeLastElement() {\n    const t = this.getLazyObserver();\n    if (!t)\n      return;\n    const e = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length - 1, s = [...this.elements][e];\n    s && t.observe(s);\n  }\n  resetVisibleElements() {\n    const t = this.getLazyObserver();\n    if (t) {\n      for (const e of this.elements)\n        t.unobserve(e);\n      this.visibleElements = [], this.observeLastElement();\n    }\n  }\n  /**\n   * Creates a new UI component instance based on the provided template and initial state.\n   *\n   * @template T - The type of the UI component element.\n   * @template S - The type of the component state.\n   *\n   * @param template - The component template function (stateless or stateful).\n   * @param initialState - The initial state of the component (optional for stateless components).\n   * @returns The created UI component element or an array containing the element and a function to update its state.\n   */\n  static create(t, e) {\n    const s = document.createDocumentFragment();\n    if (t.length === 0)\n      return Rt(t(), s), s.firstElementChild;\n    if (!e)\n      throw new Error(\n        \"UIComponent: Initial state is required for statefull components.\"\n      );\n    let n = e;\n    const r = t, o = (l) => (n = { ...n, ...l }, Rt(r(n), s), n);\n    return o(e), [s.firstElementChild, o];\n  }\n}\nconst ke = (i, t = !0) => {\n  let e = {};\n  for (const s of i.children) {\n    const n = s, r = n.getAttribute(\"name\") || n.getAttribute(\"label\");\n    if (r) {\n      if (\"value\" in n) {\n        const o = n.value;\n        if (typeof o == \"object\" && !Array.isArray(o) && Object.keys(o).length === 0)\n          continue;\n        e[r] = n.value;\n      } else if (t) {\n        const o = ke(n);\n        if (Object.keys(o).length === 0)\n          continue;\n        e[r] = o;\n      }\n    } else\n      t && (e = { ...e, ...ke(n) });\n  }\n  return e;\n}, De = (i) => i === \"true\" || i === \"false\" ? i === \"true\" : i && !isNaN(Number(i)) && i.trim() !== \"\" ? Number(i) : i, Ko = [\">=\", \"<=\", \"=\", \">\", \"<\", \"?\", \"/\", \"#\"];\nfunction Ln(i) {\n  const t = Ko.find(\n    (a) => i.split(a).length === 2\n  ), e = i.split(t).map((a) => a.trim()), [s, n] = e, r = n.startsWith(\"'\") && n.endsWith(\"'\") ? n.replace(/'/g, \"\") : De(n);\n  return { key: s, condition: t, value: r };\n}\nconst di = (i) => {\n  try {\n    const t = [], e = i.split(/&(?![^()]*\\))/).map((s) => s.trim());\n    for (const s of e) {\n      const n = !s.startsWith(\"(\") && !s.endsWith(\")\"), r = s.startsWith(\"(\") && s.endsWith(\")\");\n      if (n) {\n        const o = Ln(s);\n        t.push(o);\n      }\n      if (r) {\n        const c = {\n          operator: \"&\",\n          queries: s.replace(/^(\\()|(\\))$/g, \"\").split(\"&\").map((u) => u.trim()).map((u, h) => {\n            const f = Ln(u);\n            return h > 0 && (f.operator = \"&\"), f;\n          })\n        };\n        t.push(c);\n      }\n    }\n    return t;\n  } catch {\n    return null;\n  }\n}, In = (i, t, e) => {\n  let s = !1;\n  switch (t) {\n    case \"=\":\n      s = i === e;\n      break;\n    case \"?\":\n      s = String(i).includes(String(e));\n      break;\n    case \"<\":\n      (typeof i == \"number\" || typeof e == \"number\") && (s = i < e);\n      break;\n    case \"<=\":\n      (typeof i == \"number\" || typeof e == \"number\") && (s = i <= e);\n      break;\n    case \">\":\n      (typeof i == \"number\" || typeof e == \"number\") && (s = i > e);\n      break;\n    case \">=\":\n      (typeof i == \"number\" || typeof e == \"number\") && (s = i >= e);\n      break;\n    case \"/\":\n      s = String(i).startsWith(String(e));\n      break;\n  }\n  return s;\n};\nvar Zo = Object.defineProperty, tl = Object.getOwnPropertyDescriptor, bt = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? tl(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && Zo(t, e, n), n;\n};\nconst Ti = class Ti extends w {\n  constructor() {\n    super(...arguments), this.checked = !1, this.checkbox = !1, this.noMark = !1, this.vertical = !1;\n  }\n  get value() {\n    return this._value !== void 0 ? this._value : this.label ? De(this.label) : this.label;\n  }\n  set value(t) {\n    this._value = t;\n  }\n  render() {\n    return m`\n      <div class=\"parent\" .title=${this.label ?? \"\"}>\n        ${this.img || this.icon || this.label ? m` <div style=\"display: flex; column-gap: 0.375rem\">\n              ${this.checkbox && !this.noMark ? m`<bim-checkbox\n                    style=\"pointer-events: none\"\n                    .checked=${this.checked}\n                  ></bim-checkbox>` : null}\n              <bim-label\n                .vertical=${this.vertical}\n                .icon=${this.icon}\n                .img=${this.img}\n                >${this.label}</bim-label\n              >\n            </div>` : null}\n        ${!this.checkbox && !this.noMark && this.checked ? m`<svg\n              xmlns=\"http://www.w3.org/2000/svg\"\n              height=\"1.125rem\"\n              viewBox=\"0 0 24 24\"\n              width=\"1.125rem\"\n              fill=\"#FFFFFF\"\n            >\n              <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n              <path d=\"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z\" />\n            </svg>` : null}\n        <slot></slot>\n      </div>\n    `;\n  }\n};\nTi.styles = C`\n    :host {\n      --bim-label--c: var(--bim-ui_bg-contrast-100);\n      display: block;\n      box-sizing: border-box;\n      flex: 1;\n      padding: 0rem 0.5rem;\n      border-radius: var(--bim-ui_size-4xs);\n    }\n\n    :host(:hover) {\n      cursor: pointer;\n      background-color: color-mix(\n        in lab,\n        var(--bim-selector--bgc, var(--bim-ui_bg-contrast-20)),\n        var(--bim-ui_main-base) 10%\n      );\n    }\n\n    :host([checked]) {\n      --bim-label--c: color-mix(in lab, var(--bim-ui_main-base), white 30%);\n    }\n\n    :host([checked]) svg {\n      fill: color-mix(in lab, var(--bim-ui_main-base), white 30%);\n    }\n\n    .parent {\n      box-sizing: border-box;\n      display: flex;\n      justify-content: var(--bim-option--jc, space-between);\n      column-gap: 0.5rem;\n      align-items: center;\n      min-height: 1.75rem;\n      height: 100%;\n    }\n\n    input {\n      height: 1rem;\n      width: 1rem;\n      cursor: pointer;\n      border: none;\n      outline: none;\n      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));\n    }\n\n    input:focus {\n      outline: var(--bim-checkbox--olw, 2px) solid\n        var(--bim-checkbox--olc, var(--bim-ui_accent-base));\n    }\n\n    bim-label {\n      pointer-events: none;\n    }\n  `;\nlet P = Ti;\nbt([\n  d({ type: String, reflect: !0 })\n], P.prototype, \"img\", 2);\nbt([\n  d({ type: String, reflect: !0 })\n], P.prototype, \"label\", 2);\nbt([\n  d({ type: String, reflect: !0 })\n], P.prototype, \"icon\", 2);\nbt([\n  d({ type: Boolean, reflect: !0 })\n], P.prototype, \"checked\", 2);\nbt([\n  d({ type: Boolean, reflect: !0 })\n], P.prototype, \"checkbox\", 2);\nbt([\n  d({ type: Boolean, attribute: \"no-mark\", reflect: !0 })\n], P.prototype, \"noMark\", 2);\nbt([\n  d({\n    converter: {\n      fromAttribute(i) {\n        return i && De(i);\n      }\n    }\n  })\n], P.prototype, \"value\", 1);\nbt([\n  d({ type: Boolean, reflect: !0 })\n], P.prototype, \"vertical\", 2);\nvar el = Object.defineProperty, il = Object.getOwnPropertyDescriptor, gt = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? il(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && el(t, e, n), n;\n};\nconst Li = class Li extends Jo {\n  constructor() {\n    super(), this.multiple = !1, this.required = !1, this.vertical = !1, this._inputContainer = nt(), this._listElement = nt(), this._visible = !1, this._value = [], this.onValueChange = new Event(\"change\"), this.onWindowMouseUp = (t) => {\n      this.visible && (this.contains(t.target) || (this.visible = !1));\n    }, this.onOptionClick = (t) => {\n      const e = t.target, s = this._value.includes(e);\n      if (!this.multiple && !this.required && !s)\n        this._value = [e];\n      else if (!this.multiple && !this.required && s)\n        this._value = [];\n      else if (!this.multiple && this.required && !s)\n        this._value = [e];\n      else if (this.multiple && !this.required && !s)\n        this._value = [...this._value, e];\n      else if (this.multiple && !this.required && s)\n        this._value = this._value.filter((n) => n !== e);\n      else if (this.multiple && this.required && !s)\n        this._value = [...this._value, e];\n      else if (this.multiple && this.required && s) {\n        const n = this._value.filter((r) => r !== e);\n        n.length !== 0 && (this._value = n);\n      }\n      this.updateOptionsState(), this.dispatchEvent(this.onValueChange);\n    }, this.useObserver = !0;\n  }\n  set visible(t) {\n    this._visible = t, t || this.resetVisibleElements();\n  }\n  get visible() {\n    return this._visible;\n  }\n  /**\n   * The selected values in the dropdown.\n   * @type {any[]}\n   * @example\n   * const dropdown = document.createElement('bim-dropdown');\n   * dropdown.value = ['option1', 'option2'];\n   */\n  set value(t) {\n    if (this.required && Object.keys(t).length === 0)\n      return;\n    const e = [];\n    for (const s of t) {\n      const n = this.findOption(s);\n      if (n && (e.push(n), !this.multiple && Object.keys(t).length > 1))\n        break;\n    }\n    this._value = e, this.updateOptionsState(), this.dispatchEvent(this.onValueChange);\n  }\n  get value() {\n    return this._value.filter(\n      (e) => e instanceof P && e.checked\n    ).map((e) => e.value);\n  }\n  get _options() {\n    const t = [...this.elements];\n    for (const e of this.children)\n      e instanceof P && t.push(e);\n    return t;\n  }\n  onSlotChange(t) {\n    const e = t.target.assignedElements();\n    this.observe(e);\n    for (const s of e) {\n      if (!(s instanceof P)) {\n        s.remove();\n        continue;\n      }\n      s.removeEventListener(\"click\", this.onOptionClick), s.addEventListener(\"click\", this.onOptionClick);\n    }\n  }\n  updateOptionsState() {\n    for (const t of this._options)\n      t instanceof P && (this._value.includes(t) ? t.checked = !0 : t.checked = !1);\n  }\n  findOption(t) {\n    return this._options.find((s) => s instanceof P ? s.label === t || s.value === t : !1);\n  }\n  connectedCallback() {\n    super.connectedCallback(), window.addEventListener(\"mouseup\", this.onWindowMouseUp);\n  }\n  firstUpdated() {\n    for (const t of this.children)\n      t instanceof P && t.checked && this._value.push(t);\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback(), window.removeEventListener(\"mouseup\", this.onWindowMouseUp);\n  }\n  render() {\n    let t, e, s;\n    if (this._value.length === 0)\n      t = \"Select an option...\";\n    else if (this._value.length === 1) {\n      const n = this._value[0];\n      t = (n == null ? void 0 : n.label) || (n == null ? void 0 : n.value), e = n == null ? void 0 : n.img, s = n == null ? void 0 : n.icon;\n    } else\n      t = `Multiple (${this._value.length})`;\n    return m`\n      <bim-input\n        title=${this.label ?? \"\"}\n        .label=${this.label}\n        .icon=${this.icon}\n        .vertical=${this.vertical}\n      >\n        <div\n          ${st(this._inputContainer)}\n          class=\"input\"\n          @click=${() => this.visible = !this.visible}\n        >\n          <bim-label\n            .img=${e}\n            .icon=${s}\n            style=\"overflow: hidden;\"\n            >${t}</bim-label\n          >\n          <svg\n            style=\"flex-shrink: 0\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            height=\"1.125rem\"\n            viewBox=\"0 0 24 24\"\n            width=\"1.125rem\"\n            fill=\"#9ca3af\"\n          >\n            <path d=\"M0 0h24v24H0V0z\" fill=\"none\" />\n            <path d=\"M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z\" />\n          </svg>\n        </div>\n        <bim-context-menu ${st(this._listElement)} .visible=${this.visible}>\n          <slot @slotchange=${this.onSlotChange}></slot>\n          ${this.visibleElements.map((n) => n)}\n        </bim-context-menu>\n      </bim-input>\n    `;\n  }\n};\nLi.styles = [\n  At.scrollbar,\n  C`\n      :host {\n        --bim-input--bgc: var(\n          --bim-dropdown--bgc,\n          var(--bim-ui_bg-contrast-20)\n        );\n        --bim-input--olw: var(--bim-dropdown--olw, 2px);\n        --bim-input--olc: var(--bim-dropdown--olc, transparent);\n        --bim-input--bdrs: var(--bim-dropdown--bdrs, var(--bim-ui_size-4xs));\n        flex: 1;\n        display: block;\n      }\n\n      :host([visible]) {\n        --bim-input--olc: var(\n          --bim-dropdownÂ¡focus--c,\n          var(--bim-ui_accent-base)\n        );\n      }\n\n      .input {\n        --bim-label--fz: var(--bim-drodown--fz, var(--bim-ui_size-xs));\n        --bim-label--c: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100));\n        height: 100%;\n        display: flex;\n        flex: 1;\n        overflow: hidden;\n        column-gap: 0.25rem;\n        outline: none;\n        cursor: pointer;\n        align-items: center;\n        justify-content: space-between;\n        padding: 0 0.5rem;\n      }\n\n      bim-label {\n        pointer-events: none;\n      }\n    `\n];\nlet B = Li;\ngt([\n  d({ type: String, reflect: !0 })\n], B.prototype, \"name\", 2);\ngt([\n  d({ type: String, reflect: !0 })\n], B.prototype, \"icon\", 2);\ngt([\n  d({ type: String, reflect: !0 })\n], B.prototype, \"label\", 2);\ngt([\n  d({ type: Boolean, reflect: !0 })\n], B.prototype, \"multiple\", 2);\ngt([\n  d({ type: Boolean, reflect: !0 })\n], B.prototype, \"required\", 2);\ngt([\n  d({ type: Boolean, reflect: !0 })\n], B.prototype, \"vertical\", 2);\ngt([\n  d({ type: Boolean, reflect: !0 })\n], B.prototype, \"visible\", 1);\ngt([\n  le()\n], B.prototype, \"_value\", 2);\nvar nl = Object.defineProperty, Ls = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && nl(t, e, n), n;\n};\nconst Ii = class Ii extends w {\n  constructor() {\n    super(...arguments), this.floating = !1, this.layouts = {};\n  }\n  // private isVerticalArea(area: string) {\n  //   const { rows } = this;\n  //   const row = rows.find((row) => row.includes(area));\n  //   if (!row)\n  //     throw new Error(\n  //       `${area} wasn't defined in the grid-template of this bim-grid`,\n  //     );\n  //   const index = rows.indexOf(row);\n  //   const abovePanel = index > 0 && rows[index - 1].includes(area);\n  //   const belowPanel =\n  //     index < rows.length - 1 && rows[index + 1].includes(area);\n  //   return abovePanel || belowPanel;\n  // }\n  getUniqueAreasFromTemplate(t) {\n    const n = t.split(`\n`).map((o) => o.trim()).map((o) => o.split('\"')[1]).filter((o) => o !== void 0).flatMap((o) => o.split(/\\s+/));\n    return [...new Set(n)].filter((o) => o !== \"\");\n  }\n  firstUpdated() {\n    this._onLayoutChange = new Event(\"layoutchange\");\n  }\n  render() {\n    if (this.layout) {\n      if (this.layouts[this.layout]) {\n        this.innerHTML = \"\";\n        const t = this.layouts[this.layout], s = this.getUniqueAreasFromTemplate(t.template).map((n) => {\n          const r = t.elements[n];\n          return r && (r.style.gridArea = n), r;\n        }).filter((n) => !!n);\n        this.style.gridTemplate = t.template, this._onLayoutChange && this.dispatchEvent(this._onLayoutChange), this.append(...s);\n      }\n    } else\n      this.innerHTML = \"\", this.style.gridTemplate = \"\", this._onLayoutChange && this.dispatchEvent(this._onLayoutChange);\n    return m`<slot></slot>`;\n  }\n};\nIi.styles = C`\n    :host {\n      display: grid;\n      height: 100%;\n      width: 100%;\n      overflow: hidden;\n      box-sizing: border-box;\n    }\n\n    /* :host(:not([layout])) {\n      display: none;\n    } */\n\n    :host([floating]) {\n      --bim-panel--bdrs: var(--bim-ui_size-4xs);\n      background-color: transparent;\n      padding: 1rem;\n      gap: 1rem;\n      position: absolute;\n      pointer-events: none;\n      top: 0px;\n      left: 0px;\n    }\n\n    :host(:not([floating])) {\n      --bim-panel--bdrs: 0;\n      background-color: var(--bim-ui_bg-contrast-20);\n      gap: 1px;\n    }\n  `;\nlet ie = Ii;\nLs([\n  d({ type: Boolean, reflect: !0 })\n], ie.prototype, \"floating\");\nLs([\n  d({ type: String, reflect: !0 })\n], ie.prototype, \"layout\");\nconst ze = class ze extends w {\n  render() {\n    return m`\n      <iconify-icon .icon=${this.icon} height=\"none\"></iconify-icon>\n    `;\n  }\n};\nze.styles = C`\n    :host {\n      height: var(--bim-icon--fz, var(--bim-ui_size-sm));\n      width: var(--bim-icon--fz, var(--bim-ui_size-sm));\n    }\n\n    iconify-icon {\n      height: var(--bim-icon--fz, var(--bim-ui_size-sm));\n      width: var(--bim-icon--fz, var(--bim-ui_size-sm));\n      color: var(--bim-icon--c);\n    }\n  `, ze.properties = {\n  icon: { type: String }\n};\nlet fi = ze;\nvar sl = Object.defineProperty, Fe = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && sl(t, e, n), n;\n};\nconst zi = class zi extends w {\n  constructor() {\n    super(...arguments), this.vertical = !1, this.onValueChange = new Event(\"change\");\n  }\n  get value() {\n    const t = {};\n    for (const e of this.children) {\n      const s = e;\n      \"value\" in s ? t[s.name || s.label] = s.value : \"checked\" in s && (t[s.name || s.label] = s.checked);\n    }\n    return t;\n  }\n  set value(t) {\n    const e = [...this.children];\n    for (const s in t) {\n      const n = e.find((a) => {\n        const l = a;\n        return l.name === s || l.label === s;\n      });\n      if (!n)\n        continue;\n      const r = n, o = t[s];\n      typeof o == \"boolean\" ? r.checked = o : r.value = o;\n    }\n  }\n  render() {\n    return m`\n      <div class=\"parent\">\n        ${this.label || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}\n        <div class=\"input\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n  }\n};\nzi.styles = C`\n    :host {\n      flex: 1;\n      display: block;\n    }\n\n    .parent {\n      display: flex;\n      flex-wrap: wrap;\n      column-gap: 1rem;\n      row-gap: 0.375rem;\n      user-select: none;\n      flex: 1;\n    }\n\n    :host(:not([vertical])) .parent {\n      justify-content: space-between;\n    }\n\n    :host([vertical]) .parent {\n      flex-direction: column;\n    }\n\n    .input {\n      overflow: hidden;\n      box-sizing: border-box;\n      display: flex;\n      align-items: center;\n      flex-wrap: wrap;\n      min-height: 1.75rem;\n      min-width: 3rem;\n      gap: var(--bim-input--g, var(--bim-ui_size-4xs));\n      padding: var(--bim-input--p, 0);\n      background-color: var(--bim-input--bgc, transparent);\n      outline: var(--bim-input--olw, 2px) solid\n        var(--bim-input--olc, transparent);\n      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));\n    }\n\n    :host(:not([vertical])) .input {\n      flex: 1;\n      justify-content: flex-end;\n    }\n\n    :host(:not([vertical])[label]) .input {\n      max-width: fit-content;\n    }\n  `;\nlet Et = zi;\nFe([\n  d({ type: String, reflect: !0 })\n], Et.prototype, \"name\");\nFe([\n  d({ type: String, reflect: !0 })\n], Et.prototype, \"label\");\nFe([\n  d({ type: String, reflect: !0 })\n], Et.prototype, \"icon\");\nFe([\n  d({ type: Boolean, reflect: !0 })\n], Et.prototype, \"vertical\");\nvar rl = Object.defineProperty, he = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && rl(t, e, n), n;\n};\nconst Ri = class Ri extends w {\n  constructor() {\n    super(...arguments), this.labelHidden = !1, this.iconHidden = !1, this.vertical = !1;\n  }\n  get value() {\n    return this.textContent ? De(this.textContent) : this.textContent;\n  }\n  render() {\n    return m`\n      <div class=\"parent\" .title=${this.textContent ?? \"\"}>\n        ${this.img ? m`<img .src=${this.img} .alt=${this.textContent || \"\"} />` : null}\n        ${!this.iconHidden && this.icon ? m`<bim-icon .icon=${this.icon}></bim-icon>` : null}\n        <p><slot></slot></p>\n      </div>\n    `;\n  }\n};\nRi.styles = C`\n    :host {\n      --bim-icon--c: var(--bim-label--c);\n      color: var(--bim-label--c, var(--bim-ui_bg-contrast-60));\n      font-size: var(--bim-label--fz, var(--bim-ui_size-xs));\n      overflow: hidden;\n      display: block;\n      white-space: nowrap;\n      line-height: 1.1rem;\n    }\n\n    .parent {\n      display: flex;\n      align-items: center;\n      column-gap: 0.25rem;\n      row-gap: 0.125rem;\n      user-select: none;\n      height: 100%;\n    }\n\n    :host([vertical]) .parent {\n      flex-direction: column;\n    }\n\n    .parent p {\n      margin: 0;\n      text-overflow: ellipsis;\n      overflow: hidden;\n    }\n\n    :host([label-hidden]) .parent p,\n    :host(:empty) .parent p {\n      display: none;\n    }\n\n    img {\n      height: 100%;\n      aspect-ratio: 1;\n      border-radius: 100%;\n      margin-right: 0.125rem;\n    }\n\n    :host(:not([vertical])) img {\n      max-height: var(\n        --bim-label_icon--sz,\n        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 1.5)\n      );\n    }\n\n    :host([vertical]) img {\n      max-height: var(\n        --bim-label_icon--sz,\n        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 4)\n      );\n    }\n  `;\nlet ct = Ri;\nhe([\n  d({ type: String, reflect: !0 })\n], ct.prototype, \"img\");\nhe([\n  d({ type: Boolean, attribute: \"label-hidden\", reflect: !0 })\n], ct.prototype, \"labelHidden\");\nhe([\n  d({ type: String, reflect: !0 })\n], ct.prototype, \"icon\");\nhe([\n  d({ type: Boolean, attribute: \"icon-hidden\", reflect: !0 })\n], ct.prototype, \"iconHidden\");\nhe([\n  d({ type: Boolean, reflect: !0 })\n], ct.prototype, \"vertical\");\nvar ol = Object.defineProperty, ll = Object.getOwnPropertyDescriptor, j = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? ll(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && ol(t, e, n), n;\n};\nconst Mi = class Mi extends w {\n  constructor() {\n    super(...arguments), this._value = 0, this.vertical = !1, this.slider = !1, this._input = nt(), this.onValueChange = new Event(\"change\");\n  }\n  set value(t) {\n    this.setValue(t.toString());\n  }\n  get value() {\n    return this._value;\n  }\n  onChange(t) {\n    t.stopPropagation();\n    const { value: e } = this._input;\n    e && this.setValue(e.value);\n  }\n  setValue(t) {\n    const { value: e } = this._input;\n    let s = t;\n    if (s = s.replace(/[^0-9.-]/g, \"\"), s = s.replace(/(\\..*)\\./g, \"$1\"), s.endsWith(\".\") || (s.lastIndexOf(\"-\") > 0 && (s = s[0] + s.substring(1).replace(/-/g, \"\")), s === \"-\" || s === \"-0\"))\n      return;\n    let n = Number(s);\n    Number.isNaN(n) || (n = this.min !== void 0 ? Math.max(n, this.min) : n, n = this.max !== void 0 ? Math.min(n, this.max) : n, this.value !== n && (this._value = n, e && (e.value = this.value.toString()), this.requestUpdate(), this.dispatchEvent(this.onValueChange)));\n  }\n  onBlur() {\n    const { value: t } = this._input;\n    t && Number.isNaN(Number(t.value)) && (t.value = this.value.toString());\n  }\n  onSliderMouseDown(t) {\n    document.body.style.cursor = \"w-resize\";\n    const { clientX: e } = t, s = this.value;\n    let n = !1;\n    const r = (l) => {\n      var v;\n      n = !0;\n      const { clientX: c } = l, u = this.step ?? 1, h = ((v = u.toString().split(\".\")[1]) == null ? void 0 : v.length) || 0, f = 1 / (this.sensitivity ?? 1), p = (c - e) / f;\n      if (Math.floor(Math.abs(p)) !== Math.abs(p))\n        return;\n      const b = s + p * u;\n      this.setValue(b.toFixed(h));\n    }, o = () => {\n      this.slider = !0, this.removeEventListener(\"blur\", o);\n    }, a = () => {\n      document.removeEventListener(\"mousemove\", r), document.body.style.cursor = \"default\", n ? n = !1 : (this.addEventListener(\"blur\", o), this.slider = !1, requestAnimationFrame(() => this.focus())), document.removeEventListener(\"mouseup\", a);\n    };\n    document.addEventListener(\"mousemove\", r), document.addEventListener(\"mouseup\", a);\n  }\n  onFocus(t) {\n    t.stopPropagation();\n    const e = (s) => {\n      s.key === \"Escape\" && (this.blur(), window.removeEventListener(\"keydown\", e));\n    };\n    window.addEventListener(\"keydown\", e);\n  }\n  connectedCallback() {\n    super.connectedCallback(), this.min && this.min > this.value && (this._value = this.min), this.max && this.max < this.value && (this._value = this.max);\n  }\n  /**\n   * Sets focus to the input element of the number input component.\n   * This method is useful for programmatically focusing the input element, for example,\n   * in response to a user action or to emphasize the input in the UI.\n   *\n   * If the input element reference is not available (not yet rendered or disconnected),\n   * this method will do nothing.\n   */\n  focus() {\n    const { value: t } = this._input;\n    t && t.focus();\n  }\n  render() {\n    const t = m`\n      ${this.pref || this.icon ? m`<bim-label\n            style=\"pointer-events: auto\"\n            @mousedown=${this.onSliderMouseDown}\n            .icon=${this.icon}\n            >${this.pref}</bim-label\n          >` : null}\n      <input\n        ${st(this._input)}\n        type=\"text\"\n        aria-label=${this.label || this.name || \"Number Input\"}\n        size=\"1\"\n        @input=${(a) => a.stopPropagation()}\n        @change=${this.onChange}\n        @blur=${this.onBlur}\n        @focus=${this.onFocus}\n        .value=${this.value.toString()}\n      />\n      ${this.suffix ? m`<bim-label\n            style=\"pointer-events: auto\"\n            @mousedown=${this.onSliderMouseDown}\n            >${this.suffix}</bim-label\n          >` : null}\n    `, e = this.min ?? -1 / 0, s = this.max ?? 1 / 0, n = 100 * (this.value - e) / (s - e), r = m`\n      <style>\n        .slider-indicator {\n          width: ${`${n}%`};\n        }\n      </style>\n      <div class=\"slider\" @mousedown=${this.onSliderMouseDown}>\n        <div class=\"slider-indicator\"></div>\n        ${this.pref || this.icon ? m`<bim-label\n              style=\"z-index: 1; margin-right: 0.125rem\"\n              .icon=${this.icon}\n              >${`${this.pref}: `}</bim-label\n            >` : null}\n        <bim-label style=\"z-index: 1;\">${this.value}</bim-label>\n        ${this.suffix ? m`<bim-label style=\"z-index: 1;\">${this.suffix}</bim-label>` : null}\n      </div>\n    `, o = `${this.label || this.name || this.pref ? `${this.label || this.name || this.pref}: ` : \"\"}${this.value}${this.suffix ?? \"\"}`;\n    return m`\n      <bim-input\n        title=${o}\n        .label=${this.label}\n        .icon=${this.icon}\n        .vertical=${this.vertical}\n      >\n        ${this.slider ? r : t}\n      </bim-input>\n    `;\n  }\n};\nMi.styles = C`\n    :host {\n      --bim-input--bgc: var(\n        --bim-number-input--bgc,\n        var(--bim-ui_bg-contrast-20)\n      );\n      --bim-input--olw: var(--bim-number-input--olw, 2px);\n      --bim-input--olc: var(--bim-number-input--olc, transparent);\n      --bim-input--bdrs: var(--bim-number-input--bdrs, var(--bim-ui_size-4xs));\n      --bim-input--p: 0 0.375rem;\n      flex: 1;\n      display: block;\n    }\n\n    :host(:focus) {\n      --bim-input--olw: var(--bim-number-input--olw, 2px);\n      --bim-input--olc: var(\n        --bim-number-inputÂ¡focus--c,\n        var(--bim-ui_accent-base)\n      );\n    }\n\n    :host(:not([slider])) bim-label {\n      --bim-label--c: var(\n        --bim-number-input_affixes--c,\n        var(--bim-ui_bg-contrast-60)\n      );\n      --bim-label--fz: var(\n        --bim-number-input_affixes--fz,\n        var(--bim-ui_size-xs)\n      );\n    }\n\n    p {\n      margin: 0;\n      padding: 0;\n    }\n\n    input {\n      background-color: transparent;\n      outline: none;\n      border: none;\n      padding: 0;\n      flex-grow: 1;\n      text-align: right;\n      font-family: inherit;\n      font-feature-settings: inherit;\n      font-variation-settings: inherit;\n      font-size: var(--bim-number-input--fz, var(--bim-ui_size-xs));\n      color: var(--bim-number-input--c, var(--bim-ui_bg-contrast-100));\n    }\n\n    :host([suffix]:not([pref])) input {\n      text-align: left;\n    }\n\n    :host([slider]) {\n      --bim-input--p: 0;\n    }\n\n    :host([slider]) .slider {\n      --bim-label--c: var(--bim-ui_bg-contrast-100);\n    }\n\n    .slider {\n      position: relative;\n      display: flex;\n      justify-content: center;\n      width: 100%;\n      height: 100%;\n      padding: 0 0.5rem;\n    }\n\n    .slider-indicator {\n      height: 100%;\n      background-color: var(--bim-ui_main-base);\n      position: absolute;\n      top: 0;\n      left: 0;\n      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));\n    }\n\n    bim-input {\n      display: flex;\n    }\n\n    bim-label {\n      pointer-events: none;\n    }\n  `;\nlet L = Mi;\nj([\n  d({ type: String, reflect: !0 })\n], L.prototype, \"name\", 2);\nj([\n  d({ type: String, reflect: !0 })\n], L.prototype, \"icon\", 2);\nj([\n  d({ type: String, reflect: !0 })\n], L.prototype, \"label\", 2);\nj([\n  d({ type: String, reflect: !0 })\n], L.prototype, \"pref\", 2);\nj([\n  d({ type: Number, reflect: !0 })\n], L.prototype, \"min\", 2);\nj([\n  d({ type: Number, reflect: !0 })\n], L.prototype, \"value\", 1);\nj([\n  d({ type: Number, reflect: !0 })\n], L.prototype, \"step\", 2);\nj([\n  d({ type: Number, reflect: !0 })\n], L.prototype, \"sensitivity\", 2);\nj([\n  d({ type: Number, reflect: !0 })\n], L.prototype, \"max\", 2);\nj([\n  d({ type: String, reflect: !0 })\n], L.prototype, \"suffix\", 2);\nj([\n  d({ type: Boolean, reflect: !0 })\n], L.prototype, \"vertical\", 2);\nj([\n  d({ type: Boolean, reflect: !0 })\n], L.prototype, \"slider\", 2);\nvar al = Object.defineProperty, cl = Object.getOwnPropertyDescriptor, de = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? cl(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && al(t, e, n), n;\n};\nconst ji = class ji extends w {\n  constructor() {\n    super(...arguments), this.onValueChange = new Event(\"change\"), this._hidden = !1, this.headerHidden = !1, this.activationButton = document.createElement(\"bim-button\");\n  }\n  set hidden(t) {\n    this._hidden = t, this.activationButton.active = !t, this.dispatchEvent(new Event(\"hiddenchange\"));\n  }\n  get hidden() {\n    return this._hidden;\n  }\n  /**\n   * The `value` getter computes and returns the current state of the panel's form elements as an object. This property is dynamic and reflects the current input values within the panel. When accessed, it traverses the panel's child elements, collecting values from those that have a `name` or `label` attribute, and constructs an object where each key corresponds to the `name` or `label` of the element, and the value is the element's value. This property is particularly useful for forms or interactive panels where the user's input needs to be retrieved programmatically. The value returned is a snapshot of the panel's state at the time of access, and it does not maintain a live link to the input elements.\n   *\n   * @type {Record<string, any>}\n   * @default {}\n   * @example <bim-panel></bim-panel> <!-- Access via JavaScript to get value -->\n   * @example\n   * const panel = document.createElement('bim-panel');\n   * document.body.appendChild(panel);\n   * console.log(panel.value); // Logs the current value object of the panel\n   */\n  get value() {\n    return ke(this);\n  }\n  /**\n   * The `value` setter allows programmatically updating the values of the panel's form elements. When a data object is passed to this property, it attempts to match the object's keys with the `name` or `label` attributes of the panel's child elements. If a match is found, the corresponding element's value is updated to the value associated with the key in the data object. This property is useful for initializing the panel with specific data or updating its state based on external inputs. Note that this operation does not affect elements without a matching `name` or `label`, and it only updates the values of elements that are direct children of the panel.\n   *\n   * @type {Record<string, any>}\n   * @example <bim-panel></bim-panel> <!-- Set value via JavaScript -->\n   * @example\n   * const panel = document.createElement('bim-panel');\n   * document.body.appendChild(panel);\n   * panel.value = { 'input-name': 'John Doe', 'checkbox-name': true };\n   */\n  set value(t) {\n    const e = [...this.children];\n    for (const s in t) {\n      const n = e.find((o) => {\n        const a = o;\n        return a.name === s || a.label === s;\n      });\n      if (!n)\n        continue;\n      const r = n;\n      r.value = t[s];\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback(), this.activationButton.active = !this.hidden, this.activationButton.onclick = () => this.hidden = !this.hidden;\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback(), this.activationButton.remove();\n  }\n  /**\n   * Collapses all `bim-panel-section` elements within the panel.\n   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `true`,\n   * effectively hiding their content from view. This can be used to programmatically minimize the space taken up by sections\n   * within the panel, making the panel more compact or to hide details that are not immediately necessary.\n   */\n  collapseSections() {\n    const t = this.querySelectorAll(\"bim-panel-section\");\n    for (const e of t)\n      e.collapsed = !0;\n  }\n  /**\n   * Expands all `bim-panel-section` elements within the panel.\n   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `false`,\n   * effectively showing their content. This can be used to programmatically reveal the content of sections within the panel,\n   * making the panel more informative or to display details that are necessary for the user.\n   */\n  expandSections() {\n    const t = this.querySelectorAll(\"bim-panel-section\");\n    for (const e of t)\n      e.collapsed = !1;\n  }\n  render() {\n    return this.activationButton.icon = this.icon, this.activationButton.label = this.label || this.name, this.activationButton.tooltipTitle = this.label || this.name, m`\n      <div class=\"parent\">\n        ${this.label || this.name || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}\n        <div class=\"sections\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n  }\n};\nji.styles = [\n  At.scrollbar,\n  C`\n      :host {\n        display: flex;\n        border-radius: var(--bim-ui_size-base);\n        background-color: var(--bim-ui_bg-base);\n        overflow: auto;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n\n      .parent {\n        display: flex;\n        flex: 1;\n        flex-direction: column;\n        pointer-events: auto;\n        overflow: auto;\n      }\n\n      .parent bim-label {\n        --bim-label--c: var(--bim-panel--c, var(--bim-ui_bg-contrast-80));\n        --bim-label--fz: var(--bim-panel--fz, var(--bim-ui_size-sm));\n        font-weight: 600;\n        padding: 1rem;\n        flex-shrink: 0;\n        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);\n      }\n\n      :host([header-hidden]) .parent bim-label {\n        display: none;\n      }\n\n      .sections {\n        display: flex;\n        flex-direction: column;\n        overflow: auto;\n      }\n\n      ::slotted(bim-panel-section:not(:last-child)) {\n        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);\n      }\n    `\n];\nlet ut = ji;\nde([\n  d({ type: String, reflect: !0 })\n], ut.prototype, \"icon\", 2);\nde([\n  d({ type: String, reflect: !0 })\n], ut.prototype, \"name\", 2);\nde([\n  d({ type: String, reflect: !0 })\n], ut.prototype, \"label\", 2);\nde([\n  d({ type: Boolean, reflect: !0 })\n], ut.prototype, \"hidden\", 1);\nde([\n  d({ type: Boolean, attribute: \"header-hidden\", reflect: !0 })\n], ut.prototype, \"headerHidden\", 2);\nvar ul = Object.defineProperty, fe = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && ul(t, e, n), n;\n};\nconst Bi = class Bi extends w {\n  constructor() {\n    super(...arguments), this.onValueChange = new Event(\"change\");\n  }\n  /**\n   * The `value` getter computes and returns the current state of the panel section's form elements as an object. This object's keys are the `name` or `label` attributes of the child elements, and the values are the corresponding values of these elements. This property is particularly useful for retrieving a consolidated view of the user's input or selections within the panel section. When the value of any child element changes, the returned object from this getter will reflect those changes, providing a dynamic snapshot of the panel section's state. Note that this property does not have a default value as it dynamically reflects the current state of the panel section's form elements.\n   * @type {Record<string, any>}\n   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a getter -->\n   * @example\n   * const section = document.createElement('bim-panel-section');\n   * console.log(section.value); // Logs the current value object\n   */\n  get value() {\n    return ke(this);\n  }\n  /**\n   * The `value` setter allows programmatically updating the values of the panel section's child elements. It accepts an object where keys correspond to the `name` or `label` attributes of the child elements, and the values are the new values to be set for these elements. This property is useful for initializing the panel section with specific values or updating its state based on external data. When the property changes, the corresponding child elements' values are updated to reflect the new state. This does not have a default value as it is a method for updating child elements' values.\n   * @type {Record<string, any>}\n   * @default undefined\n   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a setter -->\n   * @example\n   * const section = document.createElement('bim-panel-section');\n   * section.value = { 'user-settings': 'John Doe' }; // Programmatically sets the value of a child element named 'user-settings'\n   */\n  set value(t) {\n    const e = [...this.children];\n    for (const s in t) {\n      const n = e.find((o) => {\n        const a = o;\n        return a.name === s || a.label === s;\n      });\n      if (!n)\n        continue;\n      const r = n;\n      r.value = t[s];\n    }\n  }\n  onHeaderClick() {\n    this.fixed || (this.collapsed = !this.collapsed);\n  }\n  render() {\n    const t = this.label || this.icon || this.name || this.fixed, e = m`<svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      height=\"1.125rem\"\n      viewBox=\"0 0 24 24\"\n      width=\"1.125rem\"\n    >\n      <path d=\"M0 0h24v24H0V0z\" fill=\"none\" />\n      <path d=\"M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z\" />\n    </svg>`, s = m`<svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      height=\"1.125rem\"\n      viewBox=\"0 0 24 24\"\n      width=\"1.125rem\"\n    >\n      <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z\" />\n    </svg>`, n = this.collapsed ? e : s, r = m`\n      <div\n        class=\"header\"\n        title=${this.label ?? \"\"}\n        @click=${this.onHeaderClick}\n      >\n        ${this.label || this.icon || this.name ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}\n        ${this.fixed ? null : n}\n      </div>\n    `;\n    return m`\n      <div class=\"parent\">\n        ${t ? r : null}\n        <div class=\"components\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n  }\n};\nBi.styles = [\n  At.scrollbar,\n  C`\n      :host {\n        display: block;\n        pointer-events: auto;\n      }\n\n      :host(:not([fixed])) .header:hover {\n        --bim-label--c: var(--bim-ui_accent-base);\n        color: var(--bim-ui_accent-base);\n        cursor: pointer;\n      }\n\n      :host(:not([fixed])) .header:hover svg {\n        fill: var(--bim-ui_accent-base);\n      }\n\n      .header {\n        --bim-label--fz: var(--bim-ui_size-sm);\n        --bim-label--c: var(--bim-ui_bg-contrast-80);\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        font-weight: 600;\n        height: 1.5rem;\n        padding: 0.75rem 1rem;\n      }\n\n      .header svg {\n        fill: var(--bim-ui_bg-contrast-80);\n      }\n\n      .title {\n        display: flex;\n        align-items: center;\n        column-gap: 0.5rem;\n      }\n\n      .title p {\n        font-size: var(--bim-ui_size-sm);\n      }\n\n      .components {\n        display: flex;\n        flex-direction: column;\n        row-gap: 0.75rem;\n        padding: 0.125rem 1rem 1rem;\n      }\n\n      :host(:not([fixed])[collapsed]) .components {\n        display: none;\n      }\n\n      bim-label {\n        pointer-events: none;\n      }\n    `\n];\nlet ht = Bi;\nfe([\n  d({ type: String, reflect: !0 })\n], ht.prototype, \"icon\");\nfe([\n  d({ type: String, reflect: !0 })\n], ht.prototype, \"label\");\nfe([\n  d({ type: String, reflect: !0 })\n], ht.prototype, \"name\");\nfe([\n  d({ type: Boolean, reflect: !0 })\n], ht.prototype, \"fixed\");\nfe([\n  d({ type: Boolean, reflect: !0 })\n], ht.prototype, \"collapsed\");\nvar hl = Object.defineProperty, pe = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && hl(t, e, n), n;\n};\nconst Ni = class Ni extends w {\n  constructor() {\n    super(...arguments), this.vertical = !1, this.onValueChange = new Event(\"change\"), this._canEmitEvents = !1, this._value = document.createElement(\"bim-option\"), this.onOptionClick = (t) => {\n      this._value = t.target, this.dispatchEvent(this.onValueChange);\n      for (const e of this.children)\n        e instanceof P && (e.checked = e === t.target);\n    };\n  }\n  get _options() {\n    return [...this.querySelectorAll(\"bim-option\")];\n  }\n  /**\n   * Sets the value of the selector.\n   * It finds the matching option based on the provided value and sets it as the selected option.\n   * If no matching option is found, it does nothing.\n   *\n   * @param value - The value to set for the selector.\n   */\n  set value(t) {\n    const e = this.findOption(t);\n    if (e) {\n      for (const s of this._options)\n        s.checked = s === e;\n      this._value = e, this._canEmitEvents && this.dispatchEvent(this.onValueChange);\n    }\n  }\n  get value() {\n    return this._value.value;\n  }\n  onSlotChange(t) {\n    const e = t.target.assignedElements();\n    for (const s of e)\n      s instanceof P && (s.noMark = !0, s.removeEventListener(\"click\", this.onOptionClick), s.addEventListener(\"click\", this.onOptionClick));\n  }\n  findOption(t) {\n    return this._options.find((s) => s instanceof P ? s.label === t || s.value === t : !1);\n  }\n  firstUpdated() {\n    const t = [...this.children].find(\n      (e) => e instanceof P && e.checked\n    );\n    t && (this._value = t);\n  }\n  render() {\n    return m`\n      <bim-input\n        .vertical=${this.vertical}\n        .label=${this.label}\n        .icon=${this.icon}\n      >\n        <slot @slotchange=${this.onSlotChange}></slot>\n      </bim-input>\n    `;\n  }\n};\nNi.styles = C`\n    :host {\n      --bim-input--bgc: var(--bim-ui_bg-contrast-20);\n      --bim-input--g: 0;\n      --bim-option--jc: center;\n      flex: 1;\n      display: block;\n    }\n\n    ::slotted(bim-option) {\n      border-radius: 0;\n    }\n\n    ::slotted(bim-option[checked]) {\n      --bim-label--c: var(--bim-ui_main-contrast);\n      background-color: var(--bim-ui_main-base);\n    }\n  `;\nlet dt = Ni;\npe([\n  d({ type: String, reflect: !0 })\n], dt.prototype, \"name\");\npe([\n  d({ type: String, reflect: !0 })\n], dt.prototype, \"icon\");\npe([\n  d({ type: String, reflect: !0 })\n], dt.prototype, \"label\");\npe([\n  d({ type: Boolean, reflect: !0 })\n], dt.prototype, \"vertical\");\npe([\n  le()\n], dt.prototype, \"_value\");\nvar dl = Object.defineProperty, fl = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && dl(t, e, n), n;\n};\nconst Hi = class Hi extends w {\n  constructor() {\n    super(...arguments), this.column = \"\", this.columnIndex = 0, this.rowData = {};\n  }\n  get data() {\n    return this.column ? this.rowData[this.column] : null;\n  }\n  render() {\n    return m`\n      <style>\n        :host {\n          grid-area: ${this.column ?? \"unset\"};\n        }\n      </style>\n      <slot></slot>\n    `;\n  }\n};\nHi.styles = C`\n    :host {\n      padding: 0.25rem 1rem;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n    }\n\n    :host([data-column-index=\"0\"]:not([data-cell-header])) {\n      justify-content: normal;\n    }\n\n    :host([data-column-index=\"0\"]:not([data-cell-header]))\n      ::slotted(bim-label) {\n      text-align: left;\n    }\n\n    ::slotted(*) {\n      --bim-input--bgc: transparent;\n      --bim-input--olc: var(--bim-ui_bg-contrast-20);\n      --bim-input--olw: 1px;\n    }\n\n    ::slotted(bim-input) {\n      --bim-input--olw: 0;\n    }\n\n    ::slotted(bim-label) {\n      white-space: normal;\n      text-align: center;\n    }\n  `;\nlet Pe = Hi;\nfl([\n  d({ type: String, reflect: !0 })\n], Pe.prototype, \"column\");\nvar pl = Object.defineProperty, ml = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && pl(t, e, n), n;\n};\nconst Di = class Di extends w {\n  constructor() {\n    super(...arguments), this._groups = [], this.data = [], this.table = this.closest(\"bim-table\");\n  }\n  toggleGroups(t, e = !1) {\n    for (const s of this._groups)\n      s.childrenHidden = typeof t > \"u\" ? !s.childrenHidden : !t, e && s.toggleChildren(t, e);\n  }\n  render() {\n    return this._groups = [], m`\n      <slot></slot>\n      ${this.data.map((t) => {\n      const e = document.createElement(\n        \"bim-table-group\"\n      );\n      return this._groups.push(e), e.table = this.table, e.data = t, e;\n    })}\n    `;\n  }\n};\nDi.styles = C`\n    :host {\n      position: relative;\n      grid-area: Children;\n    }\n\n    :host([hidden]) {\n      display: none;\n    }\n\n    ::slotted(.branch.branch-vertical) {\n      top: 0;\n      bottom: 1.125rem;\n    }\n  `;\nlet Te = Di;\nml([\n  d({ type: Array, attribute: !1 })\n], Te.prototype, \"data\");\nvar bl = Object.defineProperty, gl = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && bl(t, e, n), n;\n};\nconst Fi = class Fi extends w {\n  constructor() {\n    super(...arguments), this.data = { data: {} }, this.childrenHidden = !0, this.table = this.closest(\"bim-table\");\n  }\n  connectedCallback() {\n    super.connectedCallback(), this.table && this.table.expanded ? this.childrenHidden = !1 : this.childrenHidden = !0;\n  }\n  toggleChildren(t, e = !1) {\n    this._children && (this.childrenHidden = typeof t > \"u\" ? !this.childrenHidden : !t, e && this._children.toggleGroups(t, e));\n  }\n  render() {\n    var f, p;\n    const t = ((f = this.table) == null ? void 0 : f.getGroupIndentation(this.data)) ?? 0, e = m`\n      <style>\n        .branch-vertical {\n          left: ${t + 0.5625}rem;\n        }\n      </style>\n      <div class=\"branch branch-vertical\"></div>\n    `, s = document.createDocumentFragment();\n    Rt(e, s);\n    const n = document.createElement(\"div\");\n    n.classList.add(\"branch\", \"branch-horizontal\"), n.style.left = `${t - 1 + 0.5625}rem`;\n    const r = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"svg\"\n    );\n    r.setAttribute(\"height\", \"9.5\"), r.setAttribute(\"width\", \"7.5\"), r.setAttribute(\"viewBox\", \"0 0 4.6666672 7.3333333\");\n    const o = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"path\"\n    );\n    o.setAttribute(\n      \"d\",\n      \"m 1.7470835,6.9583848 2.5899999,-2.59 c 0.39,-0.39 0.39,-1.02 0,-1.41 L 1.7470835,0.36838483 c -0.63,-0.62000003 -1.71000005,-0.18 -1.71000005,0.70999997 v 5.17 c 0,0.9 1.08000005,1.34 1.71000005,0.71 z\"\n    ), r.append(o);\n    const a = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"svg\"\n    );\n    a.setAttribute(\"height\", \"6.5\"), a.setAttribute(\"width\", \"9.5\"), a.setAttribute(\"viewBox\", \"0 0 5.9111118 5.0175439\");\n    const l = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"path\"\n    );\n    l.setAttribute(\n      \"d\",\n      \"M -0.33616196,1.922522 2.253838,4.5125219 c 0.39,0.39 1.02,0.39 1.41,0 L 6.2538379,1.922522 c 0.6200001,-0.63 0.18,-1.71000007 -0.7099999,-1.71000007 H 0.37383804 c -0.89999997,0 -1.33999997,1.08000007 -0.71,1.71000007 z\"\n    ), a.append(l);\n    const c = document.createElement(\"div\");\n    c.addEventListener(\"click\", (b) => {\n      b.stopPropagation(), this.toggleChildren();\n    }), c.classList.add(\"caret\"), c.style.left = `${0.125 + t}rem`, this.childrenHidden ? c.append(r) : c.append(a);\n    const u = document.createElement(\"bim-table-row\");\n    this.data.children && !this.childrenHidden && u.append(s), u.table = this.table, u.data = this.data.data, (p = this.table) == null || p.dispatchEvent(\n      new CustomEvent(\"rowcreated\", { detail: { row: u } })\n    ), this.data.children && u.append(c), t !== 0 && (!this.data.children || this.childrenHidden) && u.append(n);\n    let h;\n    if (this.data.children) {\n      h = document.createElement(\"bim-table-children\"), this._children = h, h.table = this.table, h.data = this.data.children;\n      const b = document.createDocumentFragment();\n      Rt(e, b), h.append(b);\n    }\n    return m`\n      <div class=\"parent\">${u} ${this.childrenHidden ? null : h}</div>\n    `;\n  }\n};\nFi.styles = C`\n    :host {\n      position: relative;\n    }\n\n    .parent {\n      display: grid;\n      grid-template-areas: \"Data\" \"Children\";\n    }\n\n    .branch {\n      position: absolute;\n      z-index: 1;\n    }\n\n    .branch-vertical {\n      border-left: 1px dotted var(--bim-ui_bg-contrast-40);\n    }\n\n    .branch-horizontal {\n      top: 50%;\n      width: 1rem;\n      border-bottom: 1px dotted var(--bim-ui_bg-contrast-40);\n    }\n\n    .caret {\n      position: absolute;\n      z-index: 2;\n      transform: translateY(-50%) rotate(0deg);\n      top: 50%;\n      display: flex;\n      width: 0.95rem;\n      height: 0.95rem;\n      justify-content: center;\n      align-items: center;\n      cursor: pointer;\n    }\n\n    .caret svg {\n      fill: var(--bim-ui_bg-contrast-60);\n    }\n  `;\nlet Le = Fi;\ngl([\n  d({ type: Boolean, attribute: \"children-hidden\", reflect: !0 })\n], Le.prototype, \"childrenHidden\");\nvar vl = Object.defineProperty, me = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && vl(t, e, n), n;\n};\nconst Vi = class Vi extends w {\n  constructor() {\n    super(...arguments), this.columns = [], this.hiddenColumns = [], this.data = {}, this.isHeader = !1, this.table = this.closest(\"bim-table\"), this.onTableColumnsChange = () => {\n      this.table && (this.columns = this.table.columns);\n    }, this.onTableColumnsHidden = () => {\n      this.table && (this.hiddenColumns = this.table.hiddenColumns);\n    }, this._observer = new IntersectionObserver(\n      (t) => {\n        this._intersecting = t[0].isIntersecting;\n      },\n      { rootMargin: \"36px\" }\n    );\n  }\n  get _columnNames() {\n    return this.columns.filter(\n      (s) => !this.hiddenColumns.includes(s.name)\n    ).map((s) => s.name);\n  }\n  get _columnWidths() {\n    return this.columns.filter(\n      (s) => !this.hiddenColumns.includes(s.name)\n    ).map((s) => s.width);\n  }\n  connectedCallback() {\n    super.connectedCallback(), this._observer.observe(this), this.table && (this.columns = this.table.columns, this.hiddenColumns = this.table.hiddenColumns, this.table.addEventListener(\"columnschange\", this.onTableColumnsChange), this.table.addEventListener(\"columnshidden\", this.onTableColumnsHidden));\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback(), this._observer.unobserve(this), this.table && (this.columns = [], this.hiddenColumns = [], this.table.removeEventListener(\"columnschange\", this.onTableColumnsChange), this.table.removeEventListener(\"columnshidden\", this.onTableColumnsHidden));\n  }\n  compute() {\n    var n, r, o;\n    const t = ((n = this.table) == null ? void 0 : n.getRowIndentation(this.data)) ?? 0, e = this.isHeader ? this.data : ((r = this.table) == null ? void 0 : r.computeRowDeclaration(this.data)) ?? this.data, s = [];\n    for (const a in e) {\n      if (this.hiddenColumns.includes(a))\n        continue;\n      const l = e[a];\n      let c;\n      if (typeof l == \"string\" || typeof l == \"boolean\" || typeof l == \"number\" ? (c = document.createElement(\"bim-label\"), c.textContent = String(l)) : l instanceof HTMLElement ? c = l : (c = document.createDocumentFragment(), Rt(l, c)), !c)\n        continue;\n      const u = document.createElement(\"bim-table-cell\");\n      u.append(c), u.column = a, this._columnNames.indexOf(a) === 0 && !this.isHeader && (u.style.marginLeft = `${t + 0.125}rem`);\n      const h = this._columnNames.indexOf(a);\n      u.setAttribute(\"data-column-index\", String(h)), u.toggleAttribute(\"data-cell-header\", this.isHeader), u.rowData = this.data, (o = this.table) == null || o.dispatchEvent(\n        new CustomEvent(\"cellcreated\", {\n          detail: { cell: u }\n        })\n      ), s.push(u);\n    }\n    return this.style.gridTemplateAreas = `\"${this._columnNames.join(\" \")}\"`, this.style.gridTemplateColumns = `${this._columnWidths.join(\" \")}`, m`\n      ${s}\n      <slot></slot>\n    `;\n  }\n  render() {\n    return m`${this._intersecting ? this.compute() : m``}`;\n  }\n};\nVi.styles = C`\n    :host {\n      position: relative;\n      grid-area: Data;\n      display: grid;\n      min-height: 2.25rem;\n    }\n\n    ::slotted(.branch.branch-vertical) {\n      top: 50%;\n      bottom: 0;\n    }\n  `;\nlet ft = Vi;\nme([\n  d({ attribute: !1 })\n], ft.prototype, \"columns\");\nme([\n  d({ attribute: !1 })\n], ft.prototype, \"hiddenColumns\");\nme([\n  d({ attribute: !1 })\n], ft.prototype, \"data\");\nme([\n  d({ type: Boolean, attribute: \"is-header\", reflect: !0 })\n], ft.prototype, \"isHeader\");\nme([\n  le()\n], ft.prototype, \"_intersecting\");\nvar yl = Object.defineProperty, _l = Object.getOwnPropertyDescriptor, Ht = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? _l(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && yl(t, e, n), n;\n};\nconst Ui = class Ui extends w {\n  constructor() {\n    super(...arguments), this._columnsChange = new Event(\"columnschange\"), this._filteredData = [], this.headersHidden = !1, this.minColWidth = \"4rem\", this._columns = [], this._textDelimiters = {\n      comma: \",\",\n      tab: \"\t\"\n    }, this._queryString = null, this._data = [], this.expanded = !1, this.preserveStructureOnFilter = !1, this.indentationInText = !1, this.dataTransform = {}, this._onColumnsHidden = new Event(\"columnshidden\"), this._hiddenColumns = [], this._stringFilterFunction = (t, e) => Object.values(e.data).some((n) => String(n).toLowerCase().includes(t.toLowerCase())), this._queryFilterFunction = (t, e) => {\n      let s = !1;\n      const n = di(t) ?? [];\n      for (const r of n) {\n        if (\"queries\" in r) {\n          s = !1;\n          break;\n        }\n        const { condition: o, value: a } = r;\n        let { key: l } = r;\n        if (l.startsWith(\"[\") && l.endsWith(\"]\")) {\n          const c = l.replace(\"[\", \"\").replace(\"]\", \"\");\n          l = c, s = Object.keys(e.data).filter((f) => f.includes(c)).map(\n            (f) => In(e.data[f], o, a)\n          ).some((f) => f);\n        } else\n          s = In(e.data[l], o, a);\n        if (!s)\n          break;\n      }\n      return s;\n    };\n  }\n  set columns(t) {\n    const e = [];\n    for (const s of t) {\n      const n = typeof s == \"string\" ? { name: s, width: `minmax(${this.minColWidth}, 1fr)` } : s;\n      e.push(n);\n    }\n    this._columns = e, this.computeMissingColumns(this.data), this.dispatchEvent(this._columnsChange);\n  }\n  get columns() {\n    return this._columns;\n  }\n  get _headerRowData() {\n    const t = {};\n    for (const e of this.columns)\n      if (typeof e == \"string\")\n        t[e] = e;\n      else {\n        const { name: s } = e;\n        t[s] = s;\n      }\n    return t;\n  }\n  /**\n   * Getter for the `value` property.\n   * Returns the filtered data if a search string is provided, otherwise returns the original data.\n   *\n   * @example\n   * ```typescript\n   * const tableValue = table.value;\n   * console.log(tableValue); // Output: The filtered or original data.\n   * ```\n   */\n  get value() {\n    return this._filteredData;\n  }\n  /**\n   * Sets the search string for filtering the table data.\n   * This property allows you to filter the table data based on a search string.\n   * If a search string is provided, the table will only display rows that match the search criteria.\n   * The search criteria can be a simple string or a complex query.\n   * If a simple string is provided, the table will filter rows based on the string's presence in any column.\n   * If a complex query is provided, the table will filter rows based on the query's conditions and values.\n   *\n   * @example\n   * ```typescript\n   * table.queryString = \"example\";\n   * ```\n   *\n   * @example\n   * ```typescript\n   * table.queryString = \"column1=\"Jhon Doe\" & column2=20\";\n   * ```\n   */\n  set queryString(t) {\n    this._queryString = t && t.trim() !== \"\" ? t.trim() : null, this.updateFilteredData();\n  }\n  get queryString() {\n    return this._queryString;\n  }\n  set data(t) {\n    this._data = t, this.updateFilteredData(), this.computeMissingColumns(t) && (this.columns = this._columns);\n  }\n  get data() {\n    return this._data;\n  }\n  get dataAsync() {\n    return new Promise((t) => {\n      setTimeout(() => {\n        t(this.data);\n      });\n    });\n  }\n  set hiddenColumns(t) {\n    this._hiddenColumns = t, setTimeout(() => {\n      this.dispatchEvent(this._onColumnsHidden);\n    });\n  }\n  get hiddenColumns() {\n    return this._hiddenColumns;\n  }\n  updateFilteredData() {\n    this.queryString ? (di(this.queryString) ? (this.filterFunction = this._queryFilterFunction, this._filteredData = this.filter(this.queryString)) : (this.filterFunction = this._stringFilterFunction, this._filteredData = this.filter(this.queryString)), this.preserveStructureOnFilter && (this._expandedBeforeFilter === void 0 && (this._expandedBeforeFilter = this.expanded), this.expanded = !0)) : (this.preserveStructureOnFilter && this._expandedBeforeFilter !== void 0 && (this.expanded = this._expandedBeforeFilter, this._expandedBeforeFilter = void 0), this._filteredData = this.data);\n  }\n  computeMissingColumns(t) {\n    let e = !1;\n    for (const s of t) {\n      const { children: n, data: r } = s;\n      for (const o in r)\n        this._columns.map((l) => typeof l == \"string\" ? l : l.name).includes(o) || (this._columns.push({\n          name: o,\n          width: `minmax(${this.minColWidth}, 1fr)`\n        }), e = !0);\n      if (n) {\n        const o = this.computeMissingColumns(n);\n        o && !e && (e = o);\n      }\n    }\n    return e;\n  }\n  generateText(t = \"comma\", e = this.value, s = \"\", n = !0) {\n    const r = this._textDelimiters[t];\n    let o = \"\";\n    const a = this.columns.map((l) => l.name);\n    if (n) {\n      this.indentationInText && (o += `Indentation${r}`);\n      const l = `${a.join(r)}\n`;\n      o += l;\n    }\n    for (const [l, c] of e.entries()) {\n      const { data: u, children: h } = c, f = this.indentationInText ? `${s}${l + 1}${r}` : \"\", p = a.map((v) => u[v] ?? \"\"), b = `${f}${p.join(r)}\n`;\n      o += b, h && (o += this.generateText(\n        t,\n        c.children,\n        `${s}${l + 1}.`,\n        !1\n      ));\n    }\n    return o;\n  }\n  /**\n   * A getter function that generates a CSV (Comma Separated Values) representation of the table data.\n   *\n   * @returns A string containing the CSV representation of the table data.\n   *\n   * @example\n   * ```typescript\n   * const csvData = table.csv;\n   * console.log(csvData); // Output: \"Column 1,Column 2\\nValue 1,Value 2\\nValue 3,Value 4\"\n   * ```\n   */\n  get csv() {\n    return this.generateText(\"comma\");\n  }\n  /**\n   * A getter function that generates a Tab Separated Values (TSV) representation of the table data.\n   *\n   * @returns A string containing the TSV representation of the table data.\n   *\n   * @example\n   * ```typescript\n   * const tsvData = table.tsv;\n   * console.log(tsvData); // Output: \"Column 1\\tColumn 2\\nValue 1\\tValue 2\\nValue 3\\tValue 4\"\n   * ```\n   */\n  get tsv() {\n    return this.generateText(\"tab\");\n  }\n  computeRowDeclaration(t) {\n    const e = {};\n    for (const s in t) {\n      const n = this.dataTransform[s];\n      n ? e[s] = n(t[s], t) : e[s] = t[s];\n    }\n    return e;\n  }\n  /**\n   * The `downloadData` method is used to download the table data in different formats.\n   *\n   * @param fileName - The name of the downloaded file. Default is \"BIM Table Data\".\n   * @param format - The format of the downloaded file. Can be \"json\", \"tsv\", or \"csv\". Default is \"json\".\n   *\n   * @returns - This method does not return any value.\n   *\n   * @example\n   * ```typescript\n   * table.downloadData(\"MyTableData\", \"tsv\");\n   * ```\n   */\n  downloadData(t = \"BIM Table Data\", e = \"json\") {\n    let s = null;\n    if (e === \"json\" && (s = new File(\n      [JSON.stringify(this.value, void 0, 2)],\n      `${t}.json`\n    )), e === \"csv\" && (s = new File([this.csv], `${t}.csv`)), e === \"tsv\" && (s = new File([this.tsv], `${t}.tsv`)), !s)\n      return;\n    const n = document.createElement(\"a\");\n    n.href = URL.createObjectURL(s), n.download = s.name, n.click(), URL.revokeObjectURL(n.href);\n  }\n  getRowIndentation(t, e = this.value, s = 0) {\n    for (const n of e) {\n      if (n.data === t)\n        return s;\n      if (n.children) {\n        const r = this.getRowIndentation(\n          t,\n          n.children,\n          s + 1\n        );\n        if (r !== null)\n          return r;\n      }\n    }\n    return null;\n  }\n  getGroupIndentation(t, e = this.value, s = 0) {\n    for (const n of e) {\n      if (n === t)\n        return s;\n      if (n.children) {\n        const r = this.getGroupIndentation(\n          t,\n          n.children,\n          s + 1\n        );\n        if (r !== null)\n          return r;\n      }\n    }\n    return null;\n  }\n  connectedCallback() {\n    super.connectedCallback(), this.dispatchEvent(new Event(\"connected\"));\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback(), this.dispatchEvent(new Event(\"disconnected\"));\n  }\n  filter(t, e = this.filterFunction ?? this._stringFilterFunction, s = this.data) {\n    const n = [];\n    for (const r of s)\n      if (e(t, r)) {\n        if (this.preserveStructureOnFilter) {\n          const a = { data: r.data };\n          if (r.children) {\n            const l = this.filter(\n              t,\n              e,\n              r.children\n            );\n            l.length && (a.children = l);\n          }\n          n.push(a);\n        } else if (n.push({ data: r.data }), r.children) {\n          const a = this.filter(\n            t,\n            e,\n            r.children\n          );\n          n.push(...a);\n        }\n      } else if (r.children) {\n        const a = this.filter(\n          t,\n          e,\n          r.children\n        );\n        this.preserveStructureOnFilter && a.length ? n.push({\n          data: r.data,\n          children: a\n        }) : n.push(...a);\n      }\n    return n;\n  }\n  render() {\n    const t = document.createElement(\"bim-table-row\");\n    t.table = this, t.isHeader = !0, t.data = this._headerRowData, t.style.gridArea = \"Header\", t.style.position = \"sticky\", t.style.top = \"0\", t.style.zIndex = \"5\";\n    const e = document.createElement(\"bim-table-children\");\n    return e.table = this, e.data = this.value, e.style.gridArea = \"Body\", e.style.backgroundColor = \"transparent\", m`\n      <div class=\"parent\">\n        ${this.headersHidden ? null : t}\n        <div style=\"overflow-x: hidden; grid-area: Body\">${e}</div>\n      </div>\n    `;\n  }\n};\nUi.styles = [\n  At.scrollbar,\n  C`\n      :host {\n        --bim-button--bgc: transparent;\n        position: relative;\n        overflow: auto;\n        display: block;\n        pointer-events: auto;\n      }\n\n      .parent {\n        display: grid;\n        grid-template:\n          \"Header\" auto\n          \"Body\" 1fr\n          \"Footer\" auto;\n        overflow: auto;\n        height: 100%;\n      }\n\n      .parent > bim-table-row[is-header] {\n        color: var(--bim-table_header--c, var(--bim-ui_bg-contrast-100));\n        background-color: var(\n          --bim-table_header--bgc,\n          var(--bim-ui_bg-contrast-20)\n        );\n      }\n\n      .controls {\n        display: flex;\n        gap: 0.375rem;\n        flex-wrap: wrap;\n        margin-bottom: 0.5rem;\n      }\n    `\n];\nlet J = Ui;\nHt([\n  le()\n], J.prototype, \"_filteredData\", 2);\nHt([\n  d({\n    type: Boolean,\n    attribute: \"headers-hidden\",\n    reflect: !0\n  })\n], J.prototype, \"headersHidden\", 2);\nHt([\n  d({ type: String, attribute: \"min-col-width\", reflect: !0 })\n], J.prototype, \"minColWidth\", 2);\nHt([\n  d({ type: Array, attribute: !1 })\n], J.prototype, \"columns\", 1);\nHt([\n  d({ type: Array, attribute: !1 })\n], J.prototype, \"data\", 1);\nHt([\n  d({ type: Boolean, reflect: !0 })\n], J.prototype, \"expanded\", 2);\nvar xl = Object.defineProperty, wl = Object.getOwnPropertyDescriptor, Ve = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? wl(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && xl(t, e, n), n;\n};\nconst qi = class qi extends w {\n  constructor() {\n    super(...arguments), this._defaultName = \"__unnamed__\", this.name = this._defaultName, this._hidden = !1;\n  }\n  set hidden(t) {\n    this._hidden = t, this.dispatchEvent(new Event(\"hiddenchange\"));\n  }\n  get hidden() {\n    return this._hidden;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    const { parentElement: t } = this;\n    if (t && this.name === this._defaultName) {\n      const e = [...t.children].indexOf(this);\n      this.name = `${this._defaultName}${e}`;\n    }\n  }\n  render() {\n    return m` <slot></slot> `;\n  }\n};\nqi.styles = C`\n    :host {\n      display: block;\n      height: 100%;\n    }\n\n    :host([hidden]) {\n      display: none;\n    }\n  `;\nlet I = qi;\nVe([\n  d({ type: String, reflect: !0 })\n], I.prototype, \"name\", 2);\nVe([\n  d({ type: String, reflect: !0 })\n], I.prototype, \"label\", 2);\nVe([\n  d({ type: String, reflect: !0 })\n], I.prototype, \"icon\", 2);\nVe([\n  d({ type: Boolean, reflect: !0 })\n], I.prototype, \"hidden\", 1);\nvar $l = Object.defineProperty, Cl = Object.getOwnPropertyDescriptor, Dt = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? Cl(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && $l(t, e, n), n;\n};\nconst Wi = class Wi extends w {\n  constructor() {\n    super(...arguments), this._switchers = [], this.bottom = !1, this.switchersHidden = !1, this.floating = !1, this.switchersFull = !1, this.onTabHiddenChange = (t) => {\n      const e = t.target;\n      e instanceof I && !e.hidden && (e.removeEventListener(\"hiddenchange\", this.onTabHiddenChange), this.tab = e.name, e.addEventListener(\"hiddenchange\", this.onTabHiddenChange));\n    };\n  }\n  set tab(t) {\n    this._tab = t;\n    const e = [...this.children], s = e.find(\n      (n) => n instanceof I && n.name === t\n    );\n    for (const n of e) {\n      if (!(n instanceof I))\n        continue;\n      n.hidden = s !== n;\n      const r = this.getTabSwitcher(n.name);\n      r && r.toggleAttribute(\"data-active\", !n.hidden);\n    }\n  }\n  get tab() {\n    return this._tab;\n  }\n  getTabSwitcher(t) {\n    return this._switchers.find(\n      (s) => s.getAttribute(\"data-name\") === t\n    );\n  }\n  createSwitchers() {\n    this._switchers = [];\n    for (const t of this.children) {\n      if (!(t instanceof I))\n        continue;\n      const e = document.createElement(\"div\");\n      e.addEventListener(\"click\", () => {\n        this.tab === t.name ? this.toggleAttribute(\"tab\", !1) : this.tab = t.name;\n      }), e.setAttribute(\"data-name\", t.name), e.className = \"switcher\";\n      const s = document.createElement(\"bim-label\");\n      s.textContent = t.label ?? \"\", s.icon = t.icon, e.append(s), this._switchers.push(e);\n    }\n  }\n  onSlotChange(t) {\n    this.createSwitchers();\n    const e = t.target.assignedElements(), s = e.find((n) => n instanceof I ? this.tab ? n.name === this.tab : !n.hidden : !1);\n    s && s instanceof I && (this.tab = s.name);\n    for (const n of e) {\n      if (!(n instanceof I)) {\n        n.remove();\n        continue;\n      }\n      n.removeEventListener(\"hiddenchange\", this.onTabHiddenChange), s !== n && (n.hidden = !0), n.addEventListener(\"hiddenchange\", this.onTabHiddenChange);\n    }\n  }\n  render() {\n    return m`\n      <div class=\"parent\">\n        <div class=\"switchers\">${this._switchers}</div>\n        <div class=\"content\">\n          <slot @slotchange=${this.onSlotChange}></slot>\n        </div>\n      </div>\n    `;\n  }\n};\nWi.styles = [\n  At.scrollbar,\n  C`\n      * {\n        box-sizing: border-box;\n      }\n\n      :host {\n        background-color: var(--bim-ui_bg-base);\n        display: block;\n        overflow: auto;\n      }\n\n      .parent {\n        display: grid;\n        grid-template: \"switchers\" auto \"content\" 1fr;\n        height: 100%;\n      }\n\n      :host([bottom]) .parent {\n        grid-template: \"content\" 1fr \"switchers\" auto;\n      }\n\n      .switchers {\n        display: flex;\n        height: 2.25rem;\n        font-weight: 600;\n        grid-area: switchers;\n      }\n\n      .switcher {\n        --bim-label--c: var(--bim-ui_bg-contrast-80);\n        background-color: var(--bim-ui_bg-base);\n        cursor: pointer;\n        pointer-events: auto;\n        padding: 0rem 0.75rem;\n        display: flex;\n        justify-content: center;\n      }\n\n      :host([switchers-full]) .switcher {\n        flex: 1;\n      }\n\n      .switcher:hover,\n      .switcher[data-active] {\n        --bim-label--c: var(--bim-ui_main-contrast);\n        background-color: var(--bim-ui_main-base);\n      }\n\n      .switchers bim-label {\n        pointer-events: none;\n      }\n\n      :host([switchers-hidden]) .switchers {\n        display: none;\n      }\n\n      .content {\n        grid-area: content;\n        overflow: auto;\n      }\n\n      :host(:not([bottom])) .content {\n        border-top: 1px solid var(--bim-ui_bg-contrast-20);\n      }\n\n      :host([bottom]) .content {\n        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);\n      }\n\n      :host(:not([tab])) .content {\n        display: none;\n      }\n\n      :host([floating]) {\n        background-color: transparent;\n      }\n\n      :host([floating]) .switchers {\n        justify-self: center;\n        overflow: auto;\n      }\n\n      :host([floating]:not([bottom])) .switchers {\n        border-radius: var(--bim-ui_size-2xs) var(--bim-ui_size-2xs) 0 0;\n        border-top: 1px solid var(--bim-ui_bg-contrast-20);\n        border-left: 1px solid var(--bim-ui_bg-contrast-20);\n        border-right: 1px solid var(--bim-ui_bg-contrast-20);\n      }\n\n      :host([floating][bottom]) .switchers {\n        border-radius: 0 0 var(--bim-ui_size-2xs) var(--bim-ui_size-2xs);\n        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);\n        border-left: 1px solid var(--bim-ui_bg-contrast-20);\n        border-right: 1px solid var(--bim-ui_bg-contrast-20);\n      }\n\n      :host([floating]:not([tab])) .switchers {\n        border-radius: var(--bim-ui_size-2xs);\n        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);\n      }\n\n      :host([floating][bottom]:not([tab])) .switchers {\n        border-top: 1px solid var(--bim-ui_bg-contrast-20);\n      }\n\n      :host([floating]) .content {\n        border: 1px solid var(--bim-ui_bg-contrast-20);\n        border-radius: var(--bim-ui_size-2xs);\n        background-color: var(--bim-ui_bg-base);\n      }\n    `\n];\nlet K = Wi;\nDt([\n  le()\n], K.prototype, \"_switchers\", 2);\nDt([\n  d({ type: Boolean, reflect: !0 })\n], K.prototype, \"bottom\", 2);\nDt([\n  d({ type: Boolean, attribute: \"switchers-hidden\", reflect: !0 })\n], K.prototype, \"switchersHidden\", 2);\nDt([\n  d({ type: Boolean, reflect: !0 })\n], K.prototype, \"floating\", 2);\nDt([\n  d({ type: String, reflect: !0 })\n], K.prototype, \"tab\", 1);\nDt([\n  d({ type: Boolean, attribute: \"switchers-full\", reflect: !0 })\n], K.prototype, \"switchersFull\", 2);\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst El = (i) => i ?? k;\nvar Al = Object.defineProperty, Sl = Object.getOwnPropertyDescriptor, vt = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? Sl(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && Al(t, e, n), n;\n};\nconst Qi = class Qi extends w {\n  constructor() {\n    super(...arguments), this._inputTypes = [\n      \"date\",\n      \"datetime-local\",\n      \"email\",\n      \"month\",\n      \"password\",\n      \"search\",\n      \"tel\",\n      \"text\",\n      \"time\",\n      \"url\",\n      \"week\"\n    ], this.value = \"\", this.vertical = !1, this._type = \"text\", this.onValueChange = new Event(\"input\");\n  }\n  set type(t) {\n    this._inputTypes.includes(t) && (this._type = t);\n  }\n  get type() {\n    return this._type;\n  }\n  /**\n   * Gets the query value derived from the current input value.\n   * The `getQuery` function is assumed to be a utility function that takes a string as input\n   * and returns a processed query value based on the input.\n   *\n   * @returns The processed query value derived from the current input value.\n   *\n   * @example\n   * ```typescript\n   * const textInput = new TextInput();\n   * textInput.value = \"Key?Value\";\n   * console.log(textInput.query);\n   * ```\n   */\n  get query() {\n    return di(this.value);\n  }\n  onInputChange(t) {\n    t.stopPropagation();\n    const e = t.target;\n    clearTimeout(this._debounceTimeoutID), this._debounceTimeoutID = setTimeout(() => {\n      this.value = e.value, this.dispatchEvent(this.onValueChange);\n    }, this.debounce);\n  }\n  focus() {\n    setTimeout(() => {\n      var e;\n      const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector(\"input\");\n      t == null || t.focus();\n    });\n  }\n  render() {\n    return m`\n      <bim-input\n        .name=${this.name}\n        .icon=${this.icon}\n        .label=${this.label}\n        .vertical=${this.vertical}\n      >\n        <input\n          aria-label=${this.label || this.name || \"Text Input\"}\n          .type=${this.type}\n          .value=${this.value}\n          placeholder=${El(this.placeholder)}\n          @input=${this.onInputChange}\n        />\n      </bim-input>\n    `;\n  }\n};\nQi.styles = C`\n    :host {\n      --bim-input--bgc: var(--bim-ui_bg-contrast-20);\n      flex: 1;\n      display: block;\n    }\n\n    input {\n      background-color: transparent;\n      outline: none;\n      border: none;\n      width: 100%;\n      height: 100%;\n      padding: 0 var(--bim-ui_size-3xs);\n      border-radius: var(--bim-text-input--bdrs, var(--bim-ui_size-4xs));\n      color: var(--bim-text-input--c, var(--bim-ui_bg-contrast-100));\n    }\n\n    :host(:focus) {\n      --bim-input--olc: var(--bim-ui_accent-base);\n    }\n\n    /* :host([disabled]) {\n      --bim-input--bgc: var(--bim-ui_bg-contrast-20);\n    } */\n  `;\nlet N = Qi;\nvt([\n  d({ type: String, reflect: !0 })\n], N.prototype, \"icon\", 2);\nvt([\n  d({ type: String, reflect: !0 })\n], N.prototype, \"label\", 2);\nvt([\n  d({ type: String, reflect: !0 })\n], N.prototype, \"name\", 2);\nvt([\n  d({ type: String, reflect: !0 })\n], N.prototype, \"placeholder\", 2);\nvt([\n  d({ type: String, reflect: !0 })\n], N.prototype, \"value\", 2);\nvt([\n  d({ type: Boolean, reflect: !0 })\n], N.prototype, \"vertical\", 2);\nvt([\n  d({ type: Number, reflect: !0 })\n], N.prototype, \"debounce\", 2);\nvt([\n  d({ type: String, reflect: !0 })\n], N.prototype, \"type\", 1);\nvar Ol = Object.defineProperty, kl = Object.getOwnPropertyDescriptor, Is = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? kl(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && Ol(t, e, n), n;\n};\nconst Yi = class Yi extends w {\n  constructor() {\n    super(...arguments), this.rows = 2, this._vertical = !1;\n  }\n  set vertical(t) {\n    this._vertical = t, this.updateChildren();\n  }\n  get vertical() {\n    return this._vertical;\n  }\n  updateChildren() {\n    const t = this.children;\n    for (const e of t)\n      this.vertical ? e.setAttribute(\"label-hidden\", \"\") : e.removeAttribute(\"label-hidden\");\n  }\n  render() {\n    return m`\n      <style>\n        .parent {\n          grid-auto-flow: ${this.vertical ? \"row\" : \"column\"};\n          grid-template-rows: repeat(${this.rows}, 1fr);\n        }\n      </style>\n      <div class=\"parent\">\n        <slot @slotchange=${this.updateChildren}></slot>\n      </div>\n    `;\n  }\n};\nYi.styles = C`\n    .parent {\n      display: grid;\n      gap: 0.25rem;\n    }\n\n    ::slotted(bim-button[label]:not([vertical])) {\n      --bim-button--jc: flex-start;\n    }\n\n    ::slotted(bim-button) {\n      --bim-label--c: var(--bim-ui_bg-contrast-80);\n    }\n  `;\nlet Mt = Yi;\nIs([\n  d({ type: Number, reflect: !0 })\n], Mt.prototype, \"rows\", 2);\nIs([\n  d({ type: Boolean, reflect: !0 })\n], Mt.prototype, \"vertical\", 1);\nvar Pl = Object.defineProperty, Tl = Object.getOwnPropertyDescriptor, Ue = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? Tl(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && Pl(t, e, n), n;\n};\nconst Gi = class Gi extends w {\n  constructor() {\n    super(...arguments), this._vertical = !1, this._labelHidden = !1;\n  }\n  set vertical(t) {\n    this._vertical = t, this.updateChildren();\n  }\n  get vertical() {\n    return this._vertical;\n  }\n  set labelHidden(t) {\n    this._labelHidden = t, this.updateChildren();\n  }\n  get labelHidden() {\n    return this._labelHidden;\n  }\n  updateChildren() {\n    const t = this.children;\n    for (const e of t)\n      e instanceof Mt && (e.vertical = this.vertical), e.toggleAttribute(\"label-hidden\", this.vertical);\n  }\n  render() {\n    return m`\n      <div class=\"parent\">\n        <div class=\"children\">\n          <slot @slotchange=${this.updateChildren}></slot>\n        </div>\n        ${!this.labelHidden && (this.label || this.icon) ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}\n      </div>\n    `;\n  }\n};\nGi.styles = C`\n    :host {\n      --bim-label--fz: var(--bim-ui_size-xs);\n      --bim-label--c: var(--bim-ui_bg-contrast-60);\n      display: block;\n      flex: 1;\n    }\n\n    :host(:not([vertical])) ::slotted(bim-button[vertical]) {\n      --bim-icon--fz: var(--bim-ui_size-5xl);\n      min-height: 3.75rem;\n    }\n\n    ::slotted(bim-button) {\n      --bim-label--c: var(--bim-ui_bg-contrast-80);\n    }\n\n    .parent {\n      display: flex;\n      flex-direction: column;\n      gap: 0.5rem;\n      align-items: center;\n      padding: 0.5rem;\n      height: 100%;\n      box-sizing: border-box;\n      justify-content: space-between;\n    }\n\n    :host([vertical]) .parent {\n      flex-direction: row-reverse;\n    }\n\n    :host([vertical]) .parent > bim-label {\n      writing-mode: tb;\n    }\n\n    .children {\n      display: flex;\n      gap: 0.25rem;\n    }\n\n    :host([vertical]) .children {\n      flex-direction: column;\n    }\n  `;\nlet pt = Gi;\nUe([\n  d({ type: String, reflect: !0 })\n], pt.prototype, \"label\", 2);\nUe([\n  d({ type: String, reflect: !0 })\n], pt.prototype, \"icon\", 2);\nUe([\n  d({ type: Boolean, reflect: !0 })\n], pt.prototype, \"vertical\", 1);\nUe([\n  d({ type: Boolean, attribute: \"label-hidden\", reflect: !0 })\n], pt.prototype, \"labelHidden\", 1);\nconst _ = class _ {\n  static set config(t) {\n    this._config = { ..._._config, ...t };\n  }\n  static get config() {\n    return _._config;\n  }\n  static addGlobalStyles() {\n    let t = document.querySelector(\"style[id='bim-ui']\");\n    if (t)\n      return;\n    t = document.createElement(\"style\"), t.id = \"bim-ui\", t.textContent = At.globalStyles.cssText;\n    const e = document.head.firstChild;\n    e ? document.head.insertBefore(t, e) : document.head.append(t);\n  }\n  static defineCustomElement(t, e) {\n    customElements.get(t) || customElements.define(t, e);\n  }\n  /**\n   * @deprecated Use `Manager.init()` instead.\n   */\n  static registerComponents() {\n    _.init();\n  }\n  /**\n   * Initializes the BIM UI library by defining custom elements.\n   * It ensures that all necessary styles and custom elements are registered for use in BIM UI components.\n   *\n   * @example\n   * ```typescript\n   * import { Manager } from \"@thatopen/ui\";\n   * Manager.init();\n   * ```\n   */\n  static init() {\n    _.addGlobalStyles(), _.defineCustomElement(\"bim-button\", Vo), _.defineCustomElement(\"bim-checkbox\", at), _.defineCustomElement(\"bim-color-input\", X), _.defineCustomElement(\"bim-context-menu\", Oe), _.defineCustomElement(\"bim-dropdown\", B), _.defineCustomElement(\"bim-grid\", ie), _.defineCustomElement(\"bim-icon\", fi), _.defineCustomElement(\"bim-input\", Et), _.defineCustomElement(\"bim-label\", ct), _.defineCustomElement(\"bim-number-input\", L), _.defineCustomElement(\"bim-option\", P), _.defineCustomElement(\"bim-panel\", ut), _.defineCustomElement(\"bim-panel-section\", ht), _.defineCustomElement(\"bim-selector\", dt), _.defineCustomElement(\"bim-table\", J), _.defineCustomElement(\"bim-tabs\", K), _.defineCustomElement(\"bim-tab\", I), _.defineCustomElement(\"bim-table-cell\", Pe), _.defineCustomElement(\"bim-table-children\", Te), _.defineCustomElement(\"bim-table-group\", Le), _.defineCustomElement(\"bim-table-row\", ft), _.defineCustomElement(\"bim-text-input\", N), _.defineCustomElement(\"bim-toolbar\", jt), _.defineCustomElement(\"bim-toolbar-group\", Mt), _.defineCustomElement(\n      \"bim-toolbar-section\",\n      pt\n    ), _.defineCustomElement(\"bim-viewport\", Ie);\n  }\n  static newRandomId() {\n    const t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let e = \"\";\n    for (let s = 0; s < 10; s++) {\n      const n = Math.floor(Math.random() * t.length);\n      e += t.charAt(n);\n    }\n    return e;\n  }\n};\n_._config = {\n  sectionLabelOnVerticalToolbar: !1\n  // draggableToolbars: true,\n  // draggablePanels: true,\n};\nlet pi = _;\nvar Ll = Object.defineProperty, Il = Object.getOwnPropertyDescriptor, Si = (i, t, e, s) => {\n  for (var n = s > 1 ? void 0 : s ? Il(t, e) : t, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);\n  return s && n && Ll(t, e, n), n;\n};\nconst Xi = class Xi extends w {\n  constructor() {\n    super(...arguments), this.labelsHidden = !1, this._vertical = !1, this._hidden = !1;\n  }\n  set vertical(t) {\n    this._vertical = t, this.updateSections();\n  }\n  get vertical() {\n    return this._vertical;\n  }\n  set hidden(t) {\n    this._hidden = t, this.dispatchEvent(new Event(\"hiddenchange\"));\n  }\n  get hidden() {\n    return this._hidden;\n  }\n  // private setActivationButton() {\n  //   this.activationButton.draggable = Manager.config.draggableToolbars;\n  //   this.activationButton.addEventListener(\n  //     \"click\",\n  //     () => (this.hidden = !this.hidden),\n  //   );\n  //   this.activationButton.setAttribute(\"data-ui-manager-id\", this._managerID);\n  //   this.activationButton.addEventListener(\"dragstart\", (e) => {\n  //     const id = this.getAttribute(\"data-ui-manager-id\");\n  //     if (e.dataTransfer && id) {\n  //       e.dataTransfer.setData(\"id\", id);\n  //       e.dataTransfer.effectAllowed = \"move\";\n  //     }\n  //     const containers = document.querySelectorAll(\"bim-toolbars-container\");\n  //     for (const container of containers) {\n  //       if (container === this.parentElement) continue;\n  //       container.dropping = true;\n  //     }\n  //   });\n  //   this.activationButton.addEventListener(\"dragend\", (e) => {\n  //     if (e.dataTransfer) e.dataTransfer.clearData();\n  //     const containers = document.querySelectorAll(\"bim-toolbars-container\");\n  //     for (const container of containers) {\n  //       container.dropping = false;\n  //     }\n  //   });\n  // }\n  updateSections() {\n    const t = this.children;\n    for (const e of t)\n      e instanceof pt && (e.labelHidden = this.vertical && !pi.config.sectionLabelOnVerticalToolbar, e.vertical = this.vertical);\n  }\n  // firstUpdated() {\n  //   this.setAttribute(\"data-ui-manager-id\", this._managerID);\n  // }\n  render() {\n    return m`\n      <div class=\"parent\">\n        <slot @slotchange=${this.updateSections}></slot>\n      </div>\n    `;\n  }\n};\nXi.styles = C`\n    :host {\n      --bim-button--bgc: transparent;\n      background-color: var(--bim-ui_bg-base);\n      border-radius: var(--bim-ui_size-2xs);\n      display: block;\n    }\n\n    :host([hidden]) {\n      display: none;\n    }\n\n    .parent {\n      display: flex;\n      width: min-content;\n      pointer-events: auto;\n    }\n\n    :host([vertical]) .parent {\n      flex-direction: column;\n    }\n\n    :host([vertical]) {\n      width: min-content;\n      border-radius: var(--bim-ui_size-2xs);\n      border: 1px solid var(--bim-ui_bg-contrast-20);\n    }\n\n    ::slotted(bim-toolbar-section:not(:last-child)) {\n      border-right: 1px solid var(--bim-ui_bg-contrast-20);\n      border-bottom: none;\n    }\n\n    :host([vertical]) ::slotted(bim-toolbar-section:not(:last-child)) {\n      border-bottom: 1px solid var(--bim-ui_bg-contrast-20);\n      border-right: none;\n    }\n  `;\nlet jt = Xi;\nSi([\n  d({ type: String, reflect: !0 })\n], jt.prototype, \"icon\", 2);\nSi([\n  d({ type: Boolean, attribute: \"labels-hidden\", reflect: !0 })\n], jt.prototype, \"labelsHidden\", 2);\nSi([\n  d({ type: Boolean, reflect: !0 })\n], jt.prototype, \"vertical\", 1);\nvar zl = Object.defineProperty, Rl = (i, t, e, s) => {\n  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)\n    (o = i[r]) && (n = o(t, e, n) || n);\n  return n && zl(t, e, n), n;\n};\nconst Ji = class Ji extends w {\n  constructor() {\n    super(), this._onResize = new Event(\"resize\"), new ResizeObserver(() => {\n      setTimeout(() => {\n        this.dispatchEvent(this._onResize);\n      });\n    }).observe(this);\n  }\n  render() {\n    return m`\n      <div class=\"parent\">\n        <slot></slot>\n      </div>\n    `;\n  }\n};\nJi.styles = C`\n    :host {\n      display: grid;\n      min-width: 0;\n      min-height: 0;\n      height: 100%;\n    }\n\n    .parent {\n      overflow: hidden;\n      position: relative;\n    }\n  `;\nlet Ie = Ji;\nRl([\n  d({ type: String, reflect: !0 })\n], Ie.prototype, \"name\");\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst zs = \"important\", Ml = \" !\" + zs, Dl = ls(class extends as {\n  constructor(i) {\n    var t;\n    if (super(i), i.type !== os.ATTRIBUTE || i.name !== \"style\" || ((t = i.strings) == null ? void 0 : t.length) > 2)\n      throw Error(\"The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.\");\n  }\n  render(i) {\n    return Object.keys(i).reduce((t, e) => {\n      const s = i[e];\n      return s == null ? t : t + `${e = e.includes(\"-\") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, \"-$&\").toLowerCase()}:${s};`;\n    }, \"\");\n  }\n  update(i, [t]) {\n    const { style: e } = i.element;\n    if (this.ft === void 0)\n      return this.ft = new Set(Object.keys(t)), this.render(t);\n    for (const s of this.ft)\n      t[s] == null && (this.ft.delete(s), s.includes(\"-\") ? e.removeProperty(s) : e[s] = null);\n    for (const s in t) {\n      const n = t[s];\n      if (n != null) {\n        this.ft.add(s);\n        const r = typeof n == \"string\" && n.endsWith(Ml);\n        s.includes(\"-\") || r ? e.setProperty(s, r ? n.slice(0, -11) : n, r ? zs : \"\") : e[s] = n;\n      }\n    }\n    return Ct;\n  }\n});\n\n\n\n//# sourceURL=webpack://ThatOpen/./node_modules/@thatopen/ui/dist/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("./static/js/that_open.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./webpack.config.js");
/******/ 	__webpack_exports__ = __webpack_exports__.panel;
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});